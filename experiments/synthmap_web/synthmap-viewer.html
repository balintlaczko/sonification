<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SynthMaps - Interactive FM Synth Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 350px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #444;
        }

        #main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #ffffff;
        }

        #controls-bottom {
            height: 80px;
            background: #2a2a2a;
            padding: 15px 20px;
            border-top: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            margin-bottom: 12px;
            color: #ffa500;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .file-input-wrapper {
            margin-bottom: 10px;
        }

        .file-input-wrapper label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }

        .file-input {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 12px;
        }

        .file-input:hover {
            border-color: #666;
        }

        .parameter-control {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 10px;
        }

        .parameter-control label {
            flex: 1;
            font-size: 13px;
            color: #ccc;
        }

        .parameter-value {
            width: 80px;
            padding: 6px 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 13px;
            text-align: right;
        }

        .parameter-value:focus {
            outline: none;
            border-color: #ffa500;
        }

        #embeddings-viz {
            height: 120px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .embedding-bar {
            position: absolute;
            bottom: 0;
            width: 2px;
            background: linear-gradient(to top, #ff6b6b, #ffa500);
            transition: height 0.2s ease;
        }

        .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .slider-container label {
            font-size: 13px;
            color: #aaa;
            white-space: nowrap;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            border-radius: 2px;
            background: #444;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffa500;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffa500;
            cursor: pointer;
            border: none;
        }

        .button {
            padding: 10px 20px;
            background: #ffa500;
            border: none;
            border-radius: 4px;
            color: #1a1a1a;
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .button:hover {
            background: #ff8c00;
        }

        .button:active {
            transform: scale(0.98);
        }

        .button.stop {
            background: #ff4444;
        }

        .button.stop:hover {
            background: #ff6666;
        }

        #info-display {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(42, 42, 42, 0.9);
            padding: 15px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        #info-display div {
            margin-bottom: 5px;
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        #loading-overlay.active {
            display: flex;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #444;
            border-top: 3px solid #ffa500;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .zoom-controls {
            display: flex;
            gap: 10px;
        }

        .zoom-button {
            width: 35px;
            height: 35px;
            background: #444;
            border: none;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .zoom-button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div class="control-group">
            <h3>Load Data Files</h3>
            <div class="file-input-wrapper">
                <label>Coordinates (JSON):</label>
                <input type="file" id="coords-file" class="file-input" accept=".json">
            </div>
            <div class="file-input-wrapper">
                <label>FM Parameters (JSON):</label>
                <input type="file" id="params-file" class="file-input" accept=".json">
            </div>
            <div class="file-input-wrapper">
                <label>Model Embeddings (JSON):</label>
                <input type="file" id="embeddings-file" class="file-input" accept=".json">
            </div>
            <div class="file-input-wrapper">
                <label>Colors (JSON):</label>
                <input type="file" id="colors-file" class="file-input" accept=".json">
            </div>
        </div>

        <div class="control-group">
            <h3>FM Synth Parameters</h3>
            <div class="parameter-control">
                <label>Carrier Freq (Hz):</label>
                <input type="number" id="carrier-freq" class="parameter-value" value="440" step="0.1">
            </div>
            <div class="parameter-control">
                <label>Harmonicity Ratio:</label>
                <input type="number" id="harm-ratio" class="parameter-value" value="1" step="0.1">
            </div>
            <div class="parameter-control">
                <label>Modulation Index:</label>
                <input type="number" id="mod-index" class="parameter-value" value="1" step="0.1">
            </div>
        </div>

        <div class="control-group">
            <h3>Model Embeddings</h3>
            <div id="embeddings-viz"></div>
        </div>

        <div class="control-group">
            <h3>Audio Control</h3>
            <button id="audio-toggle" class="button">Turn Audio On</button>
        </div>

        <div class="control-group">
            <h3>Trajectory</h3>
            <div class="parameter-control">
                <label>Trajectory Space:</label>
                <select id="trajectory-space" style="flex:1; background:#1a1a1a; color:#e0e0e0; border:1px solid #444; border-radius:4px; padding:6px;">
                    <option value="embedding" selected>Model Embeddings</option>
                    <option value="fm">FM Parameters</option>
                </select>
            </div>
            <div class="parameter-control">
                <label>A (start): <span id="traj-a-label">None</span></label>
                <button id="set-traj-a" class="button" style="padding:6px 10px;">Set A = Selected</button>
            </div>
            <div class="parameter-control">
                <label>B (end): <span id="traj-b-label">None</span></label>
                <button id="set-traj-b" class="button" style="padding:6px 10px;">Set B = Selected</button>
            </div>
            <div class="parameter-control">
                <label>Steps:</label>
                <input type="range" id="trajectory-steps" class="slider" min="2" max="200" step="1" value="30" style="width: 120px;">
                <span id="trajectory-steps-value" class="parameter-value" style="width: 50px;">30</span>
            </div>
            <div class="parameter-control">
                <label>Rate (notes/s):</label>
                <input type="range" id="trajectory-rate" class="slider" min="0.5" max="20" step="0.5" value="4" style="width: 120px;">
                <span id="trajectory-rate-value" class="parameter-value" style="width: 50px;">4.0</span>
            </div>
            <div style="display:flex; gap:10px; flex-wrap: wrap;">
                <button id="compute-trajectory" class="button">Compute Trajectory</button>
                <button id="play-trajectory" class="button">Play</button>
                <button id="clear-trajectory" class="button stop">Clear</button>
            </div>
        </div>

        <div class="control-group">
            <h3>View Controls</h3>
            <div class="parameter-control">
                <label>Point Size:</label>
                <input type="range" id="point-size" class="slider" min="0.1" max="2" value="0.2" step="0.1" style="width: 120px;">
                <span id="point-size-value" class="parameter-value" style="width: 50px;">0.2</span>
            </div>
            <div class="parameter-control">
                <label>Highlight Size:</label>
                <input type="range" id="highlight-size" class="slider" min="0.3" max="3" value="0.4" step="0.1" style="width: 120px;">
                <span id="highlight-size-value" class="parameter-value" style="width: 50px;">0.4</span>
            </div>
            <div class="parameter-control">
                <label>Trajectory Line Width:</label>
                <input type="range" id="trajectory-linewidth" class="slider" min="0.02" max="2" value="0.12" step="0.02" style="width: 120px;">
                <span id="trajectory-linewidth-value" class="parameter-value" style="width: 50px;">0.12</span>
            </div>
            <div class="zoom-controls" style="margin-top: 10px;">
                <button class="zoom-button" id="zoom-in">+</button>
                <button class="zoom-button" id="zoom-out">−</button>
                <button class="zoom-button" id="zoom-reset">⟲</button>
            </div>
        </div>

        <div class="control-group">
            <h3>Crop Mesh (XYZ Ranges)</h3>
            <div class="parameter-control">
                <label>X Min:</label>
                <input type="range" id="crop-x-min" class="slider" min="0" max="1" value="0" step="0.001" style="width: 120px;">
                <span id="crop-x-min-value" class="parameter-value" style="width: 60px;">0.00</span>
            </div>
            <div class="parameter-control">
                <label>X Max:</label>
                <input type="range" id="crop-x-max" class="slider" min="0" max="1" value="1" step="0.001" style="width: 120px;">
                <span id="crop-x-max-value" class="parameter-value" style="width: 60px;">1.00</span>
            </div>
            <div class="parameter-control">
                <label>Y Min:</label>
                <input type="range" id="crop-y-min" class="slider" min="0" max="1" value="0" step="0.001" style="width: 120px;">
                <span id="crop-y-min-value" class="parameter-value" style="width: 60px;">0.00</span>
            </div>
            <div class="parameter-control">
                <label>Y Max:</label>
                <input type="range" id="crop-y-max" class="slider" min="0" max="1" value="1" step="0.001" style="width: 120px;">
                <span id="crop-y-max-value" class="parameter-value" style="width: 60px;">1.00</span>
            </div>
            <div class="parameter-control">
                <label>Z Min:</label>
                <input type="range" id="crop-z-min" class="slider" min="0" max="1" value="0" step="0.001" style="width: 120px;">
                <span id="crop-z-min-value" class="parameter-value" style="width: 60px;">0.00</span>
            </div>
            <div class="parameter-control">
                <label>Z Max:</label>
                <input type="range" id="crop-z-max" class="slider" min="0" max="1" value="1" step="0.001" style="width: 120px;">
                <span id="crop-z-max-value" class="parameter-value" style="width: 60px;">1.00</span>
            </div>
        </div>
    </div>

    <div id="main-container">
        <div id="canvas-container">
            <div id="info-display">
                <div>Points loaded: <span id="point-count">0</span></div>
                <div>Selected: <span id="selected-point">None</div>
                <div>FPS: <span id="fps">0</span></div>
            </div>
            <div id="loading-overlay">
                <div class="loading-spinner"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ml-knn@3.0.0/lib/index.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let pointCloud, pointsGeometry;
        let highlightPoint, highlightGeometry, highlightMaterial; // Separate highlight point
        let raycaster, mouse;
        let raycasterThreshold = 0.02; // Default threshold for raycaster
        let selectedPoint = null;
        let hoveredPoint = null;
        let pointCloudGroup; // Container for rotation
        let knnClassifier = null; // KNN for point selection
        let pointPositions2D = []; // Screen space positions for KNN
        let originalSizes = []; // Store original sizes for points
        let defaultCameraPosition = new THREE.Vector3(0, 0, 20);
        let defaultPointSize = 0.2; // Default size for points
        let defaultHighlightSize = 0.4; // Default size for highlight point

    // Trajectory state
    let trajA = null; // index of A
    let trajB = null; // index of B
    let trajectoryIndices = []; // array of point indices along the path
    let trajectoryGroup = null; // container for trajectory visuals
    let trajectorySegmentsGroup = null; // Group of cylinder segments for thick line
    let trajectoryPoints = null; // THREE.Points for nodes (sprite-like)
    let trajectoryPointMaterial = null; // material for nodes
    let isTrajectoryPlaying = false;
    let trajectoryTimer = null;
    let parsedEmbeddingsCache = null; // cached embedding vectors as arrays
    let parsedFmParamsCache = null;   // cached fm parameter vectors as arrays

        // Data storage
        let coordinates = null;
        let fmParams = null;
        let embeddings = null;
        let colors = null;
        let originalColors = null; // Store original colors
        
        // Audio
        let synth = null;
        let audioEnabled = false;
        
        // Animation
        let animationId;
        let lastTime = 0;
        let frameCount = 0;
        let fpsUpdateTime = 0;
        
        // Crop state
        let cropRanges = {
            x: { min: -Infinity, max: Infinity },
            y: { min: -Infinity, max: Infinity },
            z: { min: -Infinity, max: Infinity }
        };
        let dataBBox = null; // THREE.Box3 in data/original attribute space
        
    // Crop visualization (wireframe box shown during slider interaction)
    let cropBoxGroup = null;      // Group containing fill + edges + grids + axes
    let cropBoxFill = null;       // Semi-transparent fill mesh
    let cropBoxEdges = null;      // Wireframe edges
    let cropFaceGrids = [];       // 6 custom grid line meshes (one per face)
    let gridDivisions = 8;        // Grid resolution per face (u and v)
    let gridMaterial = null;      // Shared material for grids
    let axisCornerGroups = [];    // 8 groups, each with 3 arrows + 3 labels
    let cropBoxHideTimer = null;  // Auto-hide timer
        
        // Initialize Three.js scene
        function initScene() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            // set to default position
            camera.position.copy(defaultCameraPosition);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            // Initialize raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = raycasterThreshold;
            mouse = new THREE.Vector2();
            
            // Create a group to contain the point cloud for rotation
            pointCloudGroup = new THREE.Group();
            scene.add(pointCloudGroup);
            
            // Prepare crop box group inside the same rotating container
            cropBoxGroup = new THREE.Group();
            cropBoxGroup.visible = false;
            pointCloudGroup.add(cropBoxGroup);

            // Initialize highlight point (will be added when needed)
            createHighlightPoint();
            
            // Mouse controls
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            
            // Drag controls for rotation, panning and selection
            let isDragging = false;
            let isPanning = false;
            let isSelecting = false;
            let previousMousePosition = { x: 0, y: 0 };
            let dragStartPosition = { x: 0, y: 0 };
            let rotationMode = null; // 'vertical' for Shift, 'horizontal' for Alt+Shift
            
            function onMouseDown(e) {
                // Pan with Shift + Option(Alt) + Cmd
                if (e.shiftKey && e.altKey && e.metaKey) {
                    isPanning = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                } else if (e.shiftKey) {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                    rotationMode = e.altKey ? 'horizontal' : 'vertical';
                } else {
                    isSelecting = true;
                    dragStartPosition = { x: e.clientX, y: e.clientY };
                    findNearestPoint(e.clientX, e.clientY);
                }
            }
            
            function onMouseUp(e) {
                isDragging = false;
                isPanning = false;
                isSelecting = false;
                rotationMode = null;
            }
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    // Translate the point cloud group parallel to the view plane
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    const canvas = renderer.domElement;
                    const distance = Math.abs(camera.position.z); // group is around world origin
                    const vFov = THREE.MathUtils.degToRad(camera.fov);
                    const viewHeight = 2 * Math.tan(vFov / 2) * distance;
                    const worldPerPixelY =  - viewHeight / canvas.clientHeight;
                    const worldPerPixelX = worldPerPixelY * camera.aspect;
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
                    const up = new THREE.Vector3().copy(camera.up).normalize();
                    const moveX = -deltaX * worldPerPixelX; // left drag moves scene right
                    const moveY = deltaY * worldPerPixelY;  // up drag moves scene up
                    const displacement = new THREE.Vector3()
                        .addScaledVector(right, moveX)
                        .addScaledVector(up, moveY);
                    if (pointCloudGroup) {
                        pointCloudGroup.position.add(displacement);
                    }
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                } else if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    if (pointCloudGroup) {
                        // Sensitivity (radians per pixel)
                        const radPerPixel = 0.01;

                        // Camera basis vectors in world space
                        const dir = new THREE.Vector3();
                        camera.getWorldDirection(dir);
                        const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
                        const up = new THREE.Vector3().crossVectors(right, dir).normalize();

                        if (rotationMode === 'horizontal') {
                            // Yaw: rotate around camera up (world space)
                            const yawDelta = deltaX * radPerPixel;
                            const qYawDelta = new THREE.Quaternion().setFromAxisAngle(up, yawDelta);
                            // Apply in world space so it's view-relative
                            pointCloudGroup.quaternion.premultiply(qYawDelta);
                        } else {
                            // Pitch: rotate around camera right (world space)
                            const pitchDelta = deltaY * radPerPixel;
                            const qPitchDelta = new THREE.Quaternion().setFromAxisAngle(right, pitchDelta);
                            // Apply in world space so it's view-relative
                            pointCloudGroup.quaternion.premultiply(qPitchDelta);
                        }
                    }
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                } else if (isSelecting) {
                    // Continuously update selection while dragging
                    findNearestPoint(e.clientX, e.clientY);
                }
            });
            
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseMove(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        
        function findNearestPoint(clientX, clientY) {
            if (!pointCloud || !coordinates) return;
            
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            const x = ((clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            // Ensure transforms are up-to-date before raycasting
            if (pointCloudGroup) pointCloudGroup.updateMatrixWorld(true);
            if (pointCloud) pointCloud.updateMatrixWorld(true);
            
            // Method 1: Try raycasting first for direct hits
            raycaster.setFromCamera({ x, y }, camera);
            const intersects = raycaster.intersectObject(pointCloud);
            
            if (intersects.length > 0) {
                const parsedCoords = parseFluCoMaData(coordinates);
                for (const hit of intersects) {
                    const c = parsedCoords[hit.index]?.values;
                    if (c && isPointInCrop(c)) {
                        selectPoint(hit.index);
                        return;
                    }
                }
            }
            
            // Method 2: Find nearest point in screen space
            const parsedCoords = parseFluCoMaData(coordinates);
            let minDistance = Infinity;
            let nearestIndex = -1;
            
            parsedCoords.forEach((coord, i) => {
                if (!isPointInCrop(coord.values)) return; // skip cropped-out points
                // Transform 3D point to screen space
                const vector = new THREE.Vector3(
                    coord.values[0] || 0,
                    coord.values[1] || 0,
                    coord.values[2] || 0
                );
                
                // Apply the same transformations as the point cloud
                if (pointCloud) {
                    vector.multiply(pointCloud.scale);
                    vector.add(pointCloud.position);
                }
                
                // Apply group rotation and translation (panning)
                if (pointCloudGroup) {
                    // Use quaternion to account for composed yaw/pitch
                    vector.applyQuaternion(pointCloudGroup.quaternion);
                    // Include panning translation from the group
                    vector.add(pointCloudGroup.position);
                }
                
                // Project to screen space
                vector.project(camera);
                
                // Calculate distance in screen space
                const dx = vector.x - x;
                const dy = vector.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestIndex = i;
                }
            });
            
            if (nearestIndex >= 0 && minDistance < 0.1) { // Threshold for selection
                selectPoint(nearestIndex);
            }
        }

        function onMouseWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.01;
            
            if (event.deltaY < 0) {
                camera.position.z *= (1 - zoomSpeed);
            } else {
                camera.position.z *= (1 + zoomSpeed);
            }
            
            camera.position.z = Math.max(1, Math.min(25, camera.position.z));
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Load and parse FluCoMa JSON format
        async function loadJSON(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        resolve(data);
                    } catch (err) {
                        reject(err);
                    }
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function parseFluCoMaData(data) {
            const result = [];
            for (const key in data.data) {
                result.push({
                    id: key,
                    values: data.data[key]
                });
            }
            return result;
        }

        // Create point cloud from loaded data
        function createPointCloud() {
            if (!coordinates || !colors) return;
            
            // Remove existing point cloud
            if (pointCloud) {
                pointCloudGroup.remove(pointCloud);
                pointsGeometry.dispose();
            }
            
            const parsedCoords = parseFluCoMaData(coordinates);
            const parsedColors = parseFluCoMaData(colors);
            
            const positions = [];
            const colorsArray = [];
            
            parsedCoords.forEach((coord, i) => {
                // Use 3D coordinates if available, otherwise use 2D with z=0
                positions.push(
                    coord.values[0] || 0,
                    coord.values[1] || 0,
                    coord.values[2] || 0
                );
                
                if (parsedColors[i]) {
                    colorsArray.push(
                        parsedColors[i].values[0] || 0.5,
                        parsedColors[i].values[1] || 0.5,
                        parsedColors[i].values[2] || 0.5
                    );
                } else {
                    colorsArray.push(0.5, 0.5, 0.5);
                }
            });
            
            pointsGeometry = new THREE.BufferGeometry();
            pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            // Rename color attribute to avoid GLSL collisions in custom shader
            pointsGeometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colorsArray, 3));
            // Ensure accurate raycasting bounds
            pointsGeometry.computeBoundingSphere();
            
            // Create size attribute for dynamic sizing
            const sizes = new Float32Array(parsedCoords.length);
            for (let i = 0; i < parsedCoords.length; i++) {
                sizes[i] = 1.0; // Default size
            }
            pointsGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            originalSizes = Array.from(sizes);
            
            // Store original colors for restoration
            originalColors = colorsArray.slice();
            
            // Create circular sprite texture for round points
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            
            // Compute bounding box, scaling and centering
            pointsGeometry.computeBoundingBox();
            const bbox = pointsGeometry.boundingBox;
            dataBBox = bbox.clone();
            const center = new THREE.Vector3();
            bbox.getCenter(center);
            
            // Calculate the size of the bounding box
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            
            // Scale the point cloud to fit nicely in view
            const targetSize = 20; // Target size for the largest dimension
            const scale = maxDim > 0 ? targetSize / maxDim : 1;
            
            // Shader material with view-independent cropping (optimized)
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uMap: { value: texture },
                    uMin: { value: new THREE.Vector3(bbox.min.x, bbox.min.y, bbox.min.z) },
                    uMax: { value: new THREE.Vector3(bbox.max.x, bbox.max.y, bbox.max.z) },
                    uSize: { value: defaultPointSize }
                },
                transparent: false,
                depthTest: true,
                depthWrite: true,
                blending: THREE.NoBlending,
                vertexShader: `
                    precision highp float;
                    attribute vec3 aColor;
                    varying vec3 vColor;
                    uniform vec3 uMin;
                    uniform vec3 uMax;
                    uniform float uSize;
                    void main() {
                        vColor = aColor;
                        vec3 pos = position;
                        bool inRange = (pos.x >= uMin.x && pos.x <= uMax.x) &&
                                       (pos.y >= uMin.y && pos.y <= uMax.y) &&
                                       (pos.z >= uMin.z && pos.z <= uMax.z);
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        if (!inRange) {
                            gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
                            gl_PointSize = 0.0;
                            return;
                        }
                        gl_Position = projectionMatrix * mvPosition;
                        float size = uSize * (300.0 / max(1.0, -mvPosition.z));
                        gl_PointSize = size;
                    }
                `,
                fragmentShader: `
                    precision mediump float;
                    uniform sampler2D uMap;
                    varying vec3 vColor;
                    void main() {
                        vec4 tex = texture2D(uMap, gl_PointCoord);
                        if (tex.a < 0.5) discard;
                        gl_FragColor = vec4(vColor, 1.0) * tex;
                    }
                `
            });
            
            // Sync point size with UI default
            const uiSizeEl = document.getElementById('point-size');
            if (uiSizeEl && material.uniforms && material.uniforms.uSize) {
                const uiSize = parseFloat(uiSizeEl.value);
                if (!isNaN(uiSize)) material.uniforms.uSize.value = uiSize;
            }
            
            pointCloud = new THREE.Points(pointsGeometry, material);
            
            // Apply transform after material creation
            pointCloud.scale.set(scale, scale, scale);
            pointCloud.position.set(
                -center.x * scale,
                -center.y * scale,
                -center.z * scale
            );
            
            // Add to group instead of scene
            pointCloudGroup.add(pointCloud);
            
            // Ensure crop box follows the same transforms
            if (cropBoxGroup) {
                cropBoxGroup.scale.copy(pointCloud.scale);
                cropBoxGroup.position.copy(pointCloud.position);
            }

            // Initialize crop ranges and UI
            initializeCropUI(bbox);
            
            // Update UI
            document.getElementById('point-count').textContent = parsedCoords.length;
            
            console.log(`Created point cloud with ${parsedCoords.length} points`);
            console.log(`Bounding box size: x=${size.x.toFixed(2)}, y=${size.y.toFixed(2)}, z=${size.z.toFixed(2)}`);
            console.log(`Applied scale: ${scale.toFixed(4)}`);
            console.log(`Center: x=${center.x.toFixed(2)}, y=${center.y.toFixed(2)}, z=${center.z.toFixed(2)}`);
        }

        // Select a point and update parameters
        function selectPoint(index) {
            if (!fmParams || !embeddings) return;
            
            const parsedParams = parseFluCoMaData(fmParams);
            const parsedEmbeddings = parseFluCoMaData(embeddings);
            
            if (parsedParams[index]) {
                const params = parsedParams[index].values;
                document.getElementById('carrier-freq').value = params[0].toFixed(2);
                document.getElementById('harm-ratio').value = params[1].toFixed(2);
                document.getElementById('mod-index').value = params[2].toFixed(2);
                
                if (audioEnabled && synth) {
                    updateSynth();
                }
            }
            
            if (parsedEmbeddings[index]) {
                visualizeEmbeddings(parsedEmbeddings[index].values);
            }
            
            selectedPoint = index;
            document.getElementById('selected-point').textContent = `Index ${index}`;
            
            // Highlight selected point
            updatePointHighlight(index);
        }

        function createHighlightPoint() {
            // Create circular sprite texture for highlight point
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            
            // Create geometry and material for highlight
            highlightGeometry = new THREE.BufferGeometry();
            const position = new Float32Array([0, 0, 0]);
            const color = new Float32Array([1, 1, 0]);
            highlightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(position, 3));
            highlightGeometry.setAttribute('color', new THREE.Float32BufferAttribute(color, 3));
            
            highlightMaterial = new THREE.PointsMaterial({
                size: defaultHighlightSize, // Default highlight size, will be updated by slider
                vertexColors: true,
                sizeAttenuation: true,
                map: texture,
                alphaTest: 0.5,
                transparent: true,
                depthTest: false // Render on top
            });
            
            highlightPoint = new THREE.Points(highlightGeometry, highlightMaterial);
            highlightPoint.visible = false; // Hidden by default
            // Always render highlight regardless of frustum to avoid disappearing when very close
            highlightPoint.frustumCulled = false;
        }

        function updatePointHighlight(index) {
            if (!pointCloud || !coordinates || !originalColors) return;
            
            // Hide highlight if no point selected
            if (index === null || index < 0) {
                if (highlightPoint) {
                    highlightPoint.visible = false;
                }
                selectedPoint = null;
                return;
            }
            
            const parsedCoords = parseFluCoMaData(coordinates);
            
            if (parsedCoords[index]) {
                const coord = parsedCoords[index].values;
                // Hide if cropped out
                if (!isPointInCrop(coord)) {
                    if (highlightPoint) highlightPoint.visible = false;
                    selectedPoint = index;
                    return;
                }
                // Get the position of the selected point
                const position = new Float32Array([
                    coord[0] || 0,
                    coord[1] || 0,
                    coord[2] || 0
                ]);
                
                // Get the color of the selected point
                const colorIdx = index * 3;
                const color = new Float32Array([
                    originalColors[colorIdx],
                    originalColors[colorIdx + 1],
                    originalColors[colorIdx + 2]
                ]);
                
                // Update highlight point position and color
                highlightGeometry.attributes.position.array[0] = position[0];
                highlightGeometry.attributes.position.array[1] = position[1];
                highlightGeometry.attributes.position.array[2] = position[2];
                highlightGeometry.attributes.position.needsUpdate = true;
                // Keep bounding volume in sync to avoid incorrect culling
                if (highlightGeometry.computeBoundingSphere) {
                    highlightGeometry.computeBoundingSphere();
                }
                
                highlightGeometry.attributes.color.array[0] = color[0];
                highlightGeometry.attributes.color.array[1] = color[1];
                highlightGeometry.attributes.color.array[2] = color[2];
                highlightGeometry.attributes.color.needsUpdate = true;
                
                // Apply the same transformations as the main point cloud
                if (pointCloud) {
                    highlightPoint.scale.copy(pointCloud.scale);
                    highlightPoint.position.copy(pointCloud.position);
                }
                
                // Add to the same group as the point cloud
                if (!highlightPoint.parent) {
                    pointCloudGroup.add(highlightPoint);
                }
                
                highlightPoint.visible = true;
            }
            
            // Update selected point tracking
            selectedPoint = index;
        }

        // Visualize embeddings
        function visualizeEmbeddings(values) {
            const container = document.getElementById('embeddings-viz');
            container.innerHTML = '';
            
            const maxBars = Math.min(values.length, 100); // Limit to 100 bars for performance
            const barWidth = container.clientWidth / maxBars;
            
            // Normalize values
            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min || 1;
            
            for (let i = 0; i < maxBars; i++) {
                const bar = document.createElement('div');
                bar.className = 'embedding-bar';
                bar.style.left = `${i * barWidth}px`;
                bar.style.width = `${Math.max(1, barWidth - 1)}px`;
                
                const normalizedValue = (values[i] - min) / range;
                bar.style.height = `${normalizedValue * 100}%`;
                
                container.appendChild(bar);
            }
        }

        // Audio synthesis
        async function initAudio() {
            await Tone.start();
            
            // Create FM synth
            synth = new Tone.FMSynth({
                harmonicity: 1,
                modulationIndex: 1,
                oscillator: { type: 'sine' },
                modulation: { type: 'sine' },
                envelope: {
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.5,
                    release: 0.5
                },
                modulationEnvelope: {
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.5,
                    release: 0.5
                }
            }).toDestination();
            
            synth.volume.value = -12;
        }

        function updateSynth() {
            if (!synth || !audioEnabled) return;
            
            const freq = parseFloat(document.getElementById('carrier-freq').value);
            const harmRatio = parseFloat(document.getElementById('harm-ratio').value);
            const modIndex = parseFloat(document.getElementById('mod-index').value);
            
            synth.harmonicity.value = harmRatio;
            synth.modulationIndex.value = modIndex;
            
            // Trigger note
            synth.triggerAttackRelease(freq, '8n');
        }

        // Animation loop
        function animate(currentTime) {
            animationId = requestAnimationFrame(animate);
            
            // Update FPS
            frameCount++;
            if (currentTime - fpsUpdateTime > 1000) {
                const fps = Math.round(frameCount * 1000 / (currentTime - fpsUpdateTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                fpsUpdateTime = currentTime;
            }
            
            // Rotation is applied interactively via quaternions on drag; just render
            renderer.render(scene, camera);
        }

        // Event listeners
        window.addEventListener('DOMContentLoaded', function () {
            // fetch defaultPointSize and populate slider and number box value with it
            var val = (typeof defaultPointSize !== 'undefined') ? defaultPointSize : 0.2;
            var input = document.getElementById('point-size');
            var label = document.getElementById('point-size-value');
            if (input) input.value = val;
            if (label) label.textContent = Number(val).toFixed(1);

            // fetch defaultHighlightSize
            var highlightVal = (typeof defaultHighlightSize !== 'undefined') ? defaultHighlightSize : 0.4;
            var highlightInput = document.getElementById('highlight-size');
            var highlightLabel = document.getElementById('highlight-size-value');
            if (highlightInput) highlightInput.value = highlightVal;
            if (highlightLabel) highlightLabel.textContent = Number(highlightVal).toFixed(1);
        });

        

        document.getElementById('coords-file').addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                showLoading(true);
                try {
                    coordinates = await loadJSON(e.target.files[0]);
                    createPointCloud();
                } catch (err) {
                    console.error('Error loading coordinates:', err);
                    alert('Error loading coordinates file');
                }
                showLoading(false);
            }
        });

        document.getElementById('params-file').addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                try {
                    fmParams = await loadJSON(e.target.files[0]);
                    parsedFmParamsCache = parseFluCoMaData(fmParams).map(e => e.values);
                    console.log('FM parameters loaded');
                } catch (err) {
                    console.error('Error loading parameters:', err);
                    alert('Error loading parameters file');
                }
            }
        });

        document.getElementById('embeddings-file').addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                try {
                    embeddings = await loadJSON(e.target.files[0]);
                    parsedEmbeddingsCache = parseFluCoMaData(embeddings).map(e => e.values);
                    console.log('Embeddings loaded');
                } catch (err) {
                    console.error('Error loading embeddings:', err);
                    alert('Error loading embeddings file');
                }
            }
        });

        document.getElementById('colors-file').addEventListener('change', async (e) => {
            if (e.target.files.length > 0) {
                showLoading(true);
                try {
                    colors = await loadJSON(e.target.files[0]);
                    createPointCloud();
                } catch (err) {
                    console.error('Error loading colors:', err);
                    alert('Error loading colors file');
                }
                showLoading(false);
            }
        });

        document.getElementById('audio-toggle').addEventListener('click', async () => {
            const button = document.getElementById('audio-toggle');
            
            if (!audioEnabled) {
                if (!synth) {
                    await initAudio();
                }
                audioEnabled = true;
                button.textContent = 'Turn Audio Off';
                button.classList.add('stop');
            } else {
                audioEnabled = false;
                if (synth) {
                    synth.triggerRelease();
                }
                button.textContent = 'Turn Audio On';
                button.classList.remove('stop');
            }
        });

        // Manual parameter changes
        ['carrier-freq', 'harm-ratio', 'mod-index'].forEach(id => {
            document.getElementById(id).addEventListener('change', updateSynth);
        });

        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            camera.position.z *= 0.8;
            camera.position.z = Math.max(5, camera.position.z);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            camera.position.z *= 1.2;
            camera.position.z = Math.min(100, camera.position.z);
        });

        document.getElementById('zoom-reset').addEventListener('click', () => {
            camera.position.copy(defaultCameraPosition);
            camera.lookAt(0, 0, 0);
            if (pointCloudGroup) {
                pointCloudGroup.rotation.set(0, 0, 0);
                pointCloudGroup.quaternion.identity();
                // reset position
                pointCloudGroup.position.set(0, 0, 0);
            }
        });

        function showLoading(show) {
            const overlay = document.getElementById('loading-overlay');
            if (show) {
                overlay.classList.add('active');
            } else {
                overlay.classList.remove('active');
            }
        }

        // Point size controls
        document.getElementById('point-size').addEventListener('input', (e) => {
            const size = parseFloat(e.target.value);
            document.getElementById('point-size-value').textContent = size.toFixed(1);
            
            if (pointCloud && pointCloud.material) {
                const mat = pointCloud.material;
                if (mat.uniforms && mat.uniforms.uSize) {
                    mat.uniforms.uSize.value = size;
                } else if ('size' in mat) {
                    mat.size = size;
                    mat.needsUpdate = true;
                }
            }
            // keep trajectory node size halfway between point and highlight sizes
            const hl = parseFloat(document.getElementById('highlight-size').value) || 0.4;
            const midpoint = (size + hl) / 2;
            if (trajectoryPointMaterial) {
                trajectoryPointMaterial.size = midpoint;
                trajectoryPointMaterial.needsUpdate = true;
            }
        });

        document.getElementById('highlight-size').addEventListener('input', (e) => {
            const size = parseFloat(e.target.value);
            document.getElementById('highlight-size-value').textContent = size.toFixed(1);
            
            if (highlightMaterial) {
                highlightMaterial.size = size;
                highlightMaterial.needsUpdate = true;
            }
            // update trajectory node size to midpoint(pointSize, highlightSize)
            const pt = parseFloat(document.getElementById('point-size').value) || 0.2;
            const midpoint = (pt + size) / 2;
            if (trajectoryPointMaterial) {
                trajectoryPointMaterial.size = midpoint;
                trajectoryPointMaterial.needsUpdate = true;
            }
        });

        // Line width control for trajectory
        document.getElementById('trajectory-linewidth').addEventListener('input', (e) => {
            const v = parseFloat(e.target.value);
            document.getElementById('trajectory-linewidth-value').textContent = v.toFixed(2);
            // re-render segments with new width if trajectory exists
            if (trajectoryIndices && trajectoryIndices.length > 1) {
                renderTrajectory();
            }
        });

        // Trajectory UI events
        document.getElementById('trajectory-steps').addEventListener('input', (e) => {
            document.getElementById('trajectory-steps-value').textContent = String(e.target.value);
        });
        document.getElementById('trajectory-rate').addEventListener('input', (e) => {
            const v = parseFloat(e.target.value);
            document.getElementById('trajectory-rate-value').textContent = v.toFixed(1);
        });
        document.getElementById('set-traj-a').addEventListener('click', () => {
            if (selectedPoint == null) { alert('Select a point first.'); return; }
            trajA = selectedPoint;
            document.getElementById('traj-a-label').textContent = `Index ${trajA}`;
        });
        document.getElementById('set-traj-b').addEventListener('click', () => {
            if (selectedPoint == null) { alert('Select a point first.'); return; }
            trajB = selectedPoint;
            document.getElementById('traj-b-label').textContent = `Index ${trajB}`;
        });
        document.getElementById('compute-trajectory').addEventListener('click', () => {
            computeAndRenderTrajectory();
        });
        document.getElementById('clear-trajectory').addEventListener('click', () => {
            clearTrajectory();
        });
        document.getElementById('play-trajectory').addEventListener('click', () => {
            toggleTrajectoryPlayback();
        });

        // Helpers for cropping
        function isPointInCrop(values) {
            const x = values[0] || 0;
            const y = values[1] || 0;
            const z = values[2] || 0;
            return x >= cropRanges.x.min && x <= cropRanges.x.max &&
                   y >= cropRanges.y.min && y <= cropRanges.y.max &&
                   z >= cropRanges.z.min && z <= cropRanges.z.max;
        }
        
        function initializeCropUI(bbox) {
            // Default crop to full bbox
            cropRanges.x.min = bbox.min.x; cropRanges.x.max = bbox.max.x;
            cropRanges.y.min = bbox.min.y; cropRanges.y.max = bbox.max.y;
            cropRanges.z.min = bbox.min.z; cropRanges.z.max = bbox.max.z;
            
            const inputs = [
                { minId: 'crop-x-min', maxId: 'crop-x-max', valMinId: 'crop-x-min-value', valMaxId: 'crop-x-max-value', axis: 'x', min: bbox.min.x, max: bbox.max.x },
                { minId: 'crop-y-min', maxId: 'crop-y-max', valMinId: 'crop-y-min-value', valMaxId: 'crop-y-max-value', axis: 'y', min: bbox.min.y, max: bbox.max.y },
                { minId: 'crop-z-min', maxId: 'crop-z-max', valMinId: 'crop-z-min-value', valMaxId: 'crop-z-max-value', axis: 'z', min: bbox.min.z, max: bbox.max.z },
            ];
            
            inputs.forEach(cfg => {
                const minEl = document.getElementById(cfg.minId);
                const maxEl = document.getElementById(cfg.maxId);
                const minVal = document.getElementById(cfg.valMinId);
                const maxVal = document.getElementById(cfg.valMaxId);
                if (!minEl || !maxEl) return;
                
                const step = (cfg.max - cfg.min) / 1000 || 0.001;
                minEl.min = cfg.min;
                minEl.max = cfg.max;
                minEl.step = step;
                maxEl.min = cfg.min;
                maxEl.max = cfg.max;
                maxEl.step = step;
                
                // Set initial values
                minEl.value = cfg.min;
                maxEl.value = cfg.max;
                if (minVal) minVal.textContent = Number(cfg.min).toFixed(2);
                if (maxVal) maxVal.textContent = Number(cfg.max).toFixed(2);
                
                const update = () => {
                    let minV = parseFloat(minEl.value);
                    let maxV = parseFloat(maxEl.value);
                    if (minV > maxV) {
                        // Keep ranges sane: clamp
                        const mid = (minV + maxV) / 2;
                        minV = mid; maxV = mid;
                        minEl.value = String(minV);
                        maxEl.value = String(maxV);
                    }
                    cropRanges[cfg.axis].min = minV;
                    cropRanges[cfg.axis].max = maxV;
                    if (minVal) minVal.textContent = minV.toFixed(2);
                    if (maxVal) maxVal.textContent = maxV.toFixed(2);
                    // Update shader uniforms
                    updateCropUniforms();
                    // Show crop box while interacting
                    showCropBoxDuringInteraction();
                };
                if (!minEl.dataset.initialized) {
                    minEl.addEventListener('input', update);
                    // Hide shortly after committing the change
                    minEl.addEventListener('change', () => scheduleHideCropBox());
                    minEl.dataset.initialized = '1';
                }
                if (!maxEl.dataset.initialized) {
                    maxEl.addEventListener('input', update);
                    // Hide shortly after committing the change
                    maxEl.addEventListener('change', () => scheduleHideCropBox());
                    maxEl.dataset.initialized = '1';
                }
            });
            
            // Push initial uniforms
            updateCropUniforms();
            // Prepare initial (hidden) crop box geometry to match current ranges
            updateCropBox(false);
        }

        // Ensure trajectory visuals group exists and follows point cloud transform
        function ensureTrajectoryGroup() {
            if (!trajectoryGroup) {
                trajectoryGroup = new THREE.Group();
                if (pointCloudGroup) pointCloudGroup.add(trajectoryGroup);
            }
            if (pointCloud) {
                trajectoryGroup.scale.copy(pointCloud.scale);
                trajectoryGroup.position.copy(pointCloud.position);
            }
        }

        function getEmbeddingVec(index) {
            if (!parsedEmbeddingsCache) return null;
            return parsedEmbeddingsCache[index] || null;
        }

        function getFmParamsVec(index) {
            if (!parsedFmParamsCache) return null;
            return parsedFmParamsCache[index] || null;
        }

        function linearInterpolateEmbeddings(a, b, steps) {
            const res = [];
            if (!a || !b || steps < 2) return res;
            for (let i = 0; i < steps; i++) {
                const t = steps === 1 ? 1 : i / (steps - 1);
                const v = new Array(a.length);
                for (let d = 0; d < a.length; d++) v[d] = a[d] * (1 - t) + b[d] * t;
                res.push(v);
            }
            return res;
        }

        function nearestIndexInSpace(vec, space) {
            const cache = (space === 'fm') ? parsedFmParamsCache : parsedEmbeddingsCache;
            if (!cache) return -1;
            let best = -1, bestDist = Infinity;
            for (let i = 0; i < cache.length; i++) {
                const e = cache[i];
                let s = 0;
                const L = Math.min(vec.length, e.length);
                for (let d = 0; d < L; d++) {
                    const diff = vec[d] - e[d];
                    s += diff * diff;
                }
                if (s < bestDist) { bestDist = s; best = i; }
            }
            return best;
        }

        function uniqueConsecutive(arr) {
            if (!arr || arr.length === 0) return [];
            const out = [arr[0]];
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] !== arr[i - 1]) out.push(arr[i]);
            }
            return out;
        }

        function computeAndRenderTrajectory() {
            const space = (document.getElementById('trajectory-space')?.value || 'embedding');
            if (!coordinates) { alert('Load coordinates first.'); return; }
            if (space === 'embedding' && !parsedEmbeddingsCache) { alert('Load embeddings first.'); return; }
            if (space === 'fm' && !parsedFmParamsCache) { alert('Load FM parameters first.'); return; }
            if (trajA == null || trajB == null) {
                alert('Set both A and B.');
                return;
            }
            const steps = parseInt(document.getElementById('trajectory-steps').value, 10) || 30;
            const a = space === 'fm' ? getFmParamsVec(trajA) : getEmbeddingVec(trajA);
            const b = space === 'fm' ? getFmParamsVec(trajB) : getEmbeddingVec(trajB);
            if (!a || !b) { alert('Missing vectors for A or B in selected space.'); return; }
            const interps = linearInterpolateEmbeddings(a, b, steps);
            const indices = interps.map(v => nearestIndexInSpace(v, space));
            trajectoryIndices = uniqueConsecutive(indices).filter(i => i >= 0);
            if (trajectoryIndices.length === 0) { alert('Trajectory is empty.'); return; }
            renderTrajectory();
        }

        function renderTrajectory() {
            ensureTrajectoryGroup();
            // Clear previous visuals
            if (trajectorySegmentsGroup) {
                trajectorySegmentsGroup.children.forEach(ch => {
                    if (ch.geometry) ch.geometry.dispose();
                    if (ch.material) ch.material.dispose?.();
                });
                trajectoryGroup.remove(trajectorySegmentsGroup);
                trajectorySegmentsGroup = null;
            }
            if (trajectoryPoints) { trajectoryGroup.remove(trajectoryPoints); trajectoryPoints.geometry.dispose(); trajectoryPoints = null; }

            const parsedCoords = parseFluCoMaData(coordinates);
            const posList = [];
            const nodePos = [];
            for (let idx = 0; idx < trajectoryIndices.length; idx++) {
                const i = trajectoryIndices[idx];
                const v = parsedCoords[i]?.values || [0,0,0];
                nodePos.push(v[0]||0, v[1]||0, v[2]||0);
                if (idx > 0) {
                    const prevIdx = trajectoryIndices[idx - 1];
                    const pv = parsedCoords[prevIdx]?.values || [0,0,0];
                    posList.push(pv[0]||0, pv[1]||0, pv[2]||0, v[0]||0, v[1]||0, v[2]||0);
                }
            }
            // Thick line rendered as cylinders between consecutive nodes
            const width = parseFloat(document.getElementById('trajectory-linewidth').value) || 0.12;
            trajectorySegmentsGroup = new THREE.Group();
            const cylMat = new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.95, depthTest: true });
            for (let idx = 1; idx < trajectoryIndices.length; idx++) {
                const a = parsedCoords[trajectoryIndices[idx - 1]]?.values || [0,0,0];
                const b = parsedCoords[trajectoryIndices[idx]]?.values || [0,0,0];
                const pa = new THREE.Vector3(a[0]||0, a[1]||0, a[2]||0);
                const pb = new THREE.Vector3(b[0]||0, b[1]||0, b[2]||0);
                const dir = new THREE.Vector3().subVectors(pb, pa);
                const len = Math.max(1e-6, dir.length());
                const geom = new THREE.CylinderGeometry(width, width, len, 8, 1, true);
                // orient cylinder along dir
                const mid = new THREE.Vector3().addVectors(pa, pb).multiplyScalar(0.5);
                const cyl = new THREE.Mesh(geom, cylMat);
                // rotate: default cylinder aligns with Y-axis; compute quaternion from up to dir
                const up = new THREE.Vector3(0,1,0);
                const q = new THREE.Quaternion().setFromUnitVectors(up, dir.clone().normalize());
                cyl.quaternion.copy(q);
                cyl.position.copy(mid);
                trajectorySegmentsGroup.add(cyl);
            }
            trajectoryGroup.add(trajectorySegmentsGroup);

            // Nodes: sprite-like points with original colors and highlight size
            if (originalColors) {
                const nodeGeom = new THREE.BufferGeometry();
                const nodePositions = new Float32Array(nodePos);
                nodeGeom.setAttribute('position', new THREE.BufferAttribute(nodePositions, 3));
                // Each node color from originalColors per point index
                const nodeColors = new Float32Array(trajectoryIndices.length * 3);
                for (let ni = 0; ni < trajectoryIndices.length; ni++) {
                    const ci = trajectoryIndices[ni] * 3;
                    nodeColors[ni*3] = originalColors[ci] ?? 1.0;
                    nodeColors[ni*3+1] = originalColors[ci+1] ?? 1.0;
                    nodeColors[ni*3+2] = originalColors[ci+2] ?? 0.0;
                }
                nodeGeom.setAttribute('color', new THREE.BufferAttribute(nodeColors, 3));

                // Reuse the same circular sprite texture as highlight
                const pointSizeVal = parseFloat(document.getElementById('point-size').value) || defaultPointSize;
                const highlightSizeVal = parseFloat(document.getElementById('highlight-size').value) || defaultHighlightSize;
                const nodeSize = (pointSizeVal + highlightSizeVal) / 2;
                trajectoryPointMaterial = new THREE.PointsMaterial({
                    size: nodeSize,
                    vertexColors: true,
                    sizeAttenuation: true,
                    map: highlightMaterial?.map || null,
                    alphaTest: 0.5,
                    transparent: true,
                    depthTest: false
                });
                trajectoryPoints = new THREE.Points(nodeGeom, trajectoryPointMaterial);
                trajectoryPoints.renderOrder = 3;
                trajectoryGroup.add(trajectoryPoints);
            }
        }

        function clearTrajectory() {
            trajectoryIndices = [];
            if (trajectorySegmentsGroup) {
                trajectorySegmentsGroup.children.forEach(ch => {
                    if (ch.geometry) ch.geometry.dispose();
                    if (ch.material) ch.material.dispose?.();
                });
                trajectoryGroup.remove(trajectorySegmentsGroup);
                trajectorySegmentsGroup = null;
            }
            if (trajectoryPoints) { trajectoryGroup.remove(trajectoryPoints); trajectoryPoints.geometry.dispose(); trajectoryPoints = null; }
            stopTrajectoryPlayback();
        }

        function stopTrajectoryPlayback() {
            if (trajectoryTimer) { clearInterval(trajectoryTimer); trajectoryTimer = null; }
            isTrajectoryPlaying = false;
            const btn = document.getElementById('play-trajectory');
            if (btn) btn.textContent = 'Play';
        }

        function toggleTrajectoryPlayback() {
            if (isTrajectoryPlaying) { stopTrajectoryPlayback(); return; }
            if (!trajectoryIndices || trajectoryIndices.length === 0) { alert('Compute a trajectory first.'); return; }
            const rate = parseFloat(document.getElementById('trajectory-rate').value) || 4; // notes per second
            const intervalMs = Math.max(10, 1000 / rate);
            let i = 0;
            isTrajectoryPlaying = true;
            const btn = document.getElementById('play-trajectory');
            if (btn) btn.textContent = 'Stop';
            // Immediate first note
            selectPoint(trajectoryIndices[i]);
            i++;
            trajectoryTimer = setInterval(() => {
                if (!isTrajectoryPlaying) return;
                if (i >= trajectoryIndices.length) {
                    stopTrajectoryPlayback();
                    return;
                }
                selectPoint(trajectoryIndices[i]);
                i++;
            }, intervalMs);
        }
        
        function updateCropUniforms() {
            if (!pointCloud) return;
            const mat = pointCloud.material;
            if (mat && mat.uniforms && mat.uniforms.uMin && mat.uniforms.uMax) {
                mat.uniforms.uMin.value.set(cropRanges.x.min, cropRanges.y.min, cropRanges.z.min);
                mat.uniforms.uMax.value.set(cropRanges.x.max, cropRanges.y.max, cropRanges.z.max);
            }
        }

        // --- Crop box visualization helpers ---
        function ensureCropBoxParts() {
            if (!cropBoxGroup) {
                cropBoxGroup = new THREE.Group();
                cropBoxGroup.visible = false;
                pointCloudGroup.add(cropBoxGroup);
            }
            if (!cropBoxFill) {
                cropBoxFill = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshBasicMaterial({
                        color: 0xffa500,
                        transparent: true,
                        opacity: 0.08,
                        depthWrite: false
                    })
                );
                cropBoxGroup.add(cropBoxFill);
            }
            if (!cropBoxEdges) {
                cropBoxEdges = new THREE.LineSegments(
                    new THREE.EdgesGeometry(new THREE.BoxGeometry(1, 1, 1)),
                    new THREE.LineBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.9 })
                );
                cropBoxGroup.add(cropBoxEdges);
            }
            // Create shared grid material
            if (!gridMaterial) {
                gridMaterial = new THREE.LineBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.35 });
            }
            // Create custom face grids (6 faces) if needed
            if (cropFaceGrids.length === 0) {
                for (let i = 0; i < 6; i++) {
                    const grid = new THREE.LineSegments(new THREE.BufferGeometry(), gridMaterial);
                    grid.renderOrder = 1; // draw on top of fill
                    cropFaceGrids.push(grid);
                    cropBoxGroup.add(grid);
                }
            }
            // Create axis indicators for all 8 corners if needed
            if (axisCornerGroups.length === 0) {
                const colors = { x: 0xff5555, y: 0x55ff55, z: 0x5599ff };
                for (let i = 0; i < 8; i++) {
                    const g = new THREE.Group();
                    const ax = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(), 1, colors.x, 0.15, 0.08);
                    const ay = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(), 1, colors.y, 0.15, 0.08);
                    const az = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(), 1, colors.z, 0.15, 0.08);
                    const lx = createTextSprite('X', '#ff5555');
                    const ly = createTextSprite('Y', '#55ff55');
                    const lz = createTextSprite('Z', '#5599ff');
                    g.add(ax); g.add(ay); g.add(az);
                    g.add(lx); g.add(ly); g.add(lz);
                    // stash helpers on group for updates
                    g._axes = { ax, ay, az };
                    g._labels = { lx, ly, lz };
                    cropBoxGroup.add(g);
                    axisCornerGroups.push(g);
                }
            }
        }

        function updateCropBox(show = true) {
            if (!pointCloud) return;
            ensureCropBoxParts();

            // Compute box dimensions and center in original data space
            const minX = cropRanges.x.min, maxX = cropRanges.x.max;
            const minY = cropRanges.y.min, maxY = cropRanges.y.max;
            const minZ = cropRanges.z.min, maxZ = cropRanges.z.max;
            const dx = Math.max(1e-6, maxX - minX);
            const dy = Math.max(1e-6, maxY - minY);
            const dz = Math.max(1e-6, maxZ - minZ);
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;
            const cz = (minZ + maxZ) / 2;

            // Rebuild geometries to match current size
            const geom = new THREE.BoxGeometry(dx, dy, dz);
            if (cropBoxFill.geometry) cropBoxFill.geometry.dispose();
            cropBoxFill.geometry = geom;
            cropBoxFill.position.set(cx, cy, cz);

            const edgeGeom = new THREE.EdgesGeometry(geom);
            if (cropBoxEdges.geometry) cropBoxEdges.geometry.dispose();
            cropBoxEdges.geometry = edgeGeom;
            cropBoxEdges.position.set(cx, cy, cz);

            // Update face grids geometry as even net per face
            if (cropFaceGrids.length === 6) {
                const faces = [
                    { // Z-
                        idx: 0, origin: new THREE.Vector3(minX, minY, minZ), u: new THREE.Vector3(dx, 0, 0), v: new THREE.Vector3(0, dy, 0), uCount: gridDivisions, vCount: gridDivisions
                    },
                    { // Z+
                        idx: 1, origin: new THREE.Vector3(minX, minY, maxZ), u: new THREE.Vector3(dx, 0, 0), v: new THREE.Vector3(0, dy, 0), uCount: gridDivisions, vCount: gridDivisions
                    },
                    { // Y-
                        idx: 2, origin: new THREE.Vector3(minX, minY, minZ), u: new THREE.Vector3(dx, 0, 0), v: new THREE.Vector3(0, 0, dz), uCount: gridDivisions, vCount: gridDivisions
                    },
                    { // Y+
                        idx: 3, origin: new THREE.Vector3(minX, maxY, minZ), u: new THREE.Vector3(dx, 0, 0), v: new THREE.Vector3(0, 0, dz), uCount: gridDivisions, vCount: gridDivisions
                    },
                    { // X-
                        idx: 4, origin: new THREE.Vector3(minX, minY, minZ), u: new THREE.Vector3(0, dy, 0), v: new THREE.Vector3(0, 0, dz), uCount: gridDivisions, vCount: gridDivisions
                    },
                    { // X+
                        idx: 5, origin: new THREE.Vector3(maxX, minY, minZ), u: new THREE.Vector3(0, dy, 0), v: new THREE.Vector3(0, 0, dz), uCount: gridDivisions, vCount: gridDivisions
                    },
                ];
                const eps = Math.max(dx, dy, dz) * 0.002; // small offset to avoid z-fighting
                for (const f of faces) {
                    const geom = new THREE.BufferGeometry();
                    const lines = [];
                    const baseOrigin = f.origin.clone();
                    // face normal for slight offset
                    const n = new THREE.Vector3().crossVectors(f.u, f.v).normalize().multiplyScalar(Math.max(dx, dy, dz) * 0.002);
                    // U-lines: lines parallel to u at v = t
                    for (let i = 0; i <= f.uCount; i++) {
                        const t = (f.uCount === 0) ? 0 : i / f.uCount;
                        const start = baseOrigin.clone().addScaledVector(f.v, t).add(n);
                        const end = start.clone().add(f.u);
                        lines.push(start.x, start.y, start.z, end.x, end.y, end.z);
                    }
                    // V-lines: lines parallel to v at u = t
                    for (let j = 0; j <= f.vCount; j++) {
                        const t = (f.vCount === 0) ? 0 : j / f.vCount;
                        const start = baseOrigin.clone().addScaledVector(f.u, t).add(n);
                        const end = start.clone().add(f.v);
                        lines.push(start.x, start.y, start.z, end.x, end.y, end.z);
                    }
                    const pos = new Float32Array(lines);
                    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                    if (cropFaceGrids[f.idx].geometry) cropFaceGrids[f.idx].geometry.dispose();
                    cropFaceGrids[f.idx].geometry = geom;
                }
            }

            // Update axis indicators at all 8 corners
            if (axisCornerGroups.length === 8) {
                const corners = [
                    new THREE.Vector3(minX, minY, minZ),
                    new THREE.Vector3(maxX, minY, minZ),
                    new THREE.Vector3(minX, maxY, minZ),
                    new THREE.Vector3(maxX, maxY, minZ),
                    new THREE.Vector3(minX, minY, maxZ),
                    new THREE.Vector3(maxX, minY, maxZ),
                    new THREE.Vector3(minX, maxY, maxZ),
                    new THREE.Vector3(maxX, maxY, maxZ),
                ];
                const lenBase = Math.max(Math.min(dx, dy, dz) * 0.22, (dx + dy + dz) / 70);
                const off = lenBase * 0.12;
                const s = lenBase * 0.32;
                for (let i = 0; i < 8; i++) {
                    const g = axisCornerGroups[i];
                    const c = corners[i];
                    g.position.copy(c);
                    g._axes.ax.setLength(lenBase, lenBase * 0.3, lenBase * 0.18);
                    g._axes.ay.setLength(lenBase, lenBase * 0.3, lenBase * 0.18);
                    g._axes.az.setLength(lenBase, lenBase * 0.3, lenBase * 0.18);
                    g._labels.lx.position.set(lenBase + off, 0, 0);
                    g._labels.ly.position.set(0, lenBase + off, 0);
                    g._labels.lz.position.set(0, 0, lenBase + off);
                    g._labels.lx.scale.set(s, s, 1);
                    g._labels.ly.scale.set(s, s, 1);
                    g._labels.lz.scale.set(s, s, 1);
                    g.visible = show;
                }
            }

            // Match the point cloud transform so it aligns visually
            cropBoxGroup.scale.copy(pointCloud.scale);
            cropBoxGroup.position.copy(pointCloud.position);
            cropBoxGroup.visible = show;
        }

        function showCropBoxDuringInteraction() {
            updateCropBox(true);
            if (cropBoxHideTimer) clearTimeout(cropBoxHideTimer);
            cropBoxHideTimer = setTimeout(() => {
                if (cropBoxGroup) cropBoxGroup.visible = false;
            }, 3000);
        }

        function scheduleHideCropBox(delayMs = 3000) {
            if (cropBoxHideTimer) clearTimeout(cropBoxHideTimer);
            cropBoxHideTimer = setTimeout(() => {
                if (cropBoxGroup) cropBoxGroup.visible = false;
            }, delayMs);
        }

        // Utility: create text label as a sprite
        function createTextSprite(text, color = '#ffffff') {
            const fontSize = 64;
            const padding = 16;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;
            const metrics = ctx.measureText(text);
            const w = Math.ceil(metrics.width) + padding * 2;
            const h = fontSize + padding * 2;
            canvas.width = w;
            canvas.height = h;
            // redraw with proper resolution
            const ctx2 = canvas.getContext('2d');
            ctx2.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif`;
            ctx2.textAlign = 'center';
            ctx2.textBaseline = 'middle';
            ctx2.fillStyle = color;
            // subtle shadow for legibility
            ctx2.shadowColor = 'rgba(0,0,0,0.6)';
            ctx2.shadowBlur = 6;
            ctx2.shadowOffsetX = 2;
            ctx2.shadowOffsetY = 2;
            ctx2.fillText(text, w / 2, h / 2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(material);
            // default scale; will be adjusted in update
            sprite.scale.set(1, 1, 1);
            return sprite;
        }

        // Initialize
        initScene();
        animate(0);
        
        console.log('SynthMaps initialized. Please load your data files.');
    </script>
</body>
</html>