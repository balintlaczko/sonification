<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FM Synth Perceptual Similarity Study</title>
    
    <!-- ML-Matrix library for proper MDS -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.12.1/matrix.umd.min.js"></script> -->
    <script src="libs/matrix.umd.min.js"></script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        .control-group input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .control-group input[type="range"] {
            margin-top: 5px;
        }
        
        .control-group .value-display {
            font-size: 12px;
            color: #666;
            text-align: center;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .secondary-btn {
            background-color: #2196F3;
        }
        
        .secondary-btn:hover {
            background-color: #1976D2;
        }
        
        .danger-btn {
            background-color: #f44336;
        }
        
        .danger-btn:hover {
            background-color: #d32f2f;
        }
        
        .study-section {
            margin-top: 40px;
            padding-top: 40px;
            border-top: 2px solid #eee;
        }
        
        .triplet-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        
        .sound-card {
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .sound-card.active {
            border-color: #4CAF50;
            background: #e8f5e9;
        }
        
        .sound-card h3 {
            margin: 0 0 15px 0;
            color: #333;
        }
        
        .sound-card button {
            width: 100%;
            margin: 5px 0;
        }
        
        .params-display {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            line-height: 1.5;
        }
        
        .question {
            text-align: center;
            font-size: 20px;
            margin: 30px 0;
            color: #333;
        }
        
        .choice-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .choice-btn {
            padding: 20px 40px;
            font-size: 18px;
            background-color: #FF9800;
        }
        
        .choice-btn:hover {
            background-color: #F57C00;
        }
        
        #visualization {
            margin-top: 40px;
            text-align: center;
        }
        
        #visualization-tab {
            display: none;
        }
        
        #visualization-tab.active {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-container {
            width: 100%;
            max-width: 800px;
            position: relative;
            margin: 20px auto;
        }
        
        #scatter-plot {
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: crosshair;
            width: 100%;
            height: auto;
            display: block;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .tooltip.visible {
            opacity: 1;
        }
        
        .tooltip::after {
            content: '';
            position: absolute;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
        }
        
        .tooltip[style*="--arrow-direction: bottom"]::after,
        .tooltip::after {
            top: 100%;
            border-color: rgba(0, 0, 0, 0.9) transparent transparent transparent;
        }
        
        .tooltip[style*="--arrow-direction: top"]::after {
            bottom: 100%;
            top: auto;
            border-color: transparent transparent rgba(0, 0, 0, 0.9) transparent;
        }
        
        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #4CAF50;
        }
        
        .tooltip-param {
            margin: 2px 0;
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .tooltip-label {
            color: #aaa;
        }
        
        .tooltip-value {
            font-family: monospace;
            color: #fff;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e0e0e0;
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        .loading-text {
            color: #666;
            font-size: 14px;
            text-align: center;
            line-height: 1.4;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .stats {
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 4px;
            text-align: center;
        }
        .global-data-section {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: space-between;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px 20px 5px;
            margin: -10px 0 20px; /* tighten spacing under title */
            background: #fafafa;
        }
        .global-data-section .stats { /* compact stats inside header */
            margin: 0;
            padding: 10px 15px;
        }
        
        .tab-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab.active {
            border-bottom-color: #2196F3;
            color: #2196F3;
            font-weight: 600;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Assignment Cards Styles */
        .assignment-cards-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .assignment-card {
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 8px;
            height: 200px;
            width: 185px;
            position: relative;
            transition: all 0.3s;
        }
        
        .assignment-card.assigned {
            border-color: #4CAF50;
            background: #e8f5e9;
        }
        
        .assignment-content {
            padding: 20px;
            text-align: center;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .assignment-btn {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            width: 100%;
        }
        
        .assignment-btn:hover {
            background-color: #1976D2;
        }
        
        .assignment-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .assignment-card h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }
        
        .assignment-card .play-btn {
            width: 100%;
            margin: 10px 0;
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .assignment-card .play-btn:hover {
            background-color: #45a049;
        }
        
        .assignment-card .params-display {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
            line-height: 1.5;
            text-align: left;
        }
        
        .assignment-card .remove-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #e0e0e0;
            color: #666;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .assignment-card .remove-btn:hover {
            background: #f44336;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FM Synth Perceptual Similarity Study</h1>
        <!-- Global data controls moved from Visualization tab -->
        <div class="global-data-section">
            <div class="stats">
                <strong>Data points:</strong> <span id="data-count">0</span> |
                <strong>Unique sounds:</strong> <span id="unique-sounds">0</span>
            </div>
            <div class="button-group" style="margin:0;">
                <button onclick="exportData()" class="secondary-btn">Export Data</button>
                <button onclick="importData()" class="secondary-btn">Import Data</button>
                <button onclick="showDataInConsole()" class="secondary-btn">View in Console</button>
                <button onclick="clearAllData()" class="secondary-btn danger-btn">Clear All Data</button>
                <input type="file" id="file-input" style="display:none;" accept=".json">
            </div>
        </div>
        
        <div class="tab-container">
            <div class="tab active" onclick="switchTab('test')">Test FM Synth</div>
            <div class="tab" onclick="switchTab('study')">Similarity Study</div>
            <div class="tab" onclick="switchTab('visualization')">Visualization</div>
        </div>
        
        <!-- Test FM Synth Tab -->
        <div id="test-tab" class="tab-content active">
            <h2>Test FM Synthesis Parameters</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="carrier-freq">Carrier Frequency (Hz)</label>
                    <input type="range" id="carrier-freq" min="73.42" max="1174.66" value="440" step="0.01">
                    <div class="value-display" id="carrier-freq-display">440.00 Hz</div>
                </div>
                
                <div class="control-group">
                    <label for="harm-ratio">Harmonicity Ratio</label>
                    <input type="range" id="harm-ratio" min="0" max="10" value="2" step="0.01">
                    <div class="value-display" id="harm-ratio-display">2.00</div>
                </div>
                
                <div class="control-group">
                    <label for="mod-index">Modulation Index</label>
                    <input type="range" id="mod-index" min="0" max="10" value="1" step="0.01">
                    <div class="value-display" id="mod-index-display">1.00</div>
                </div>
            </div>
            
            <div class="button-group">
                <button onclick="playTestSound()">Play Test Sound</button>
                <button onclick="randomizeParams()" class="secondary-btn">Randomize Parameters</button>
            </div>
        </div>
        
        <!-- Similarity Study Tab -->
        <div id="study-tab" class="tab-content">
            <h2>Perceptual Similarity Study</h2>
            <!-- Trials completed bar removed per request -->
            
            <div class="triplet-container">
                <div class="sound-card" id="sound-a">
                    <h3>Sound A</h3>
                    <button onclick="playTripletSound('A')">Play Sound A</button>
                    <div class="params-display" id="params-a"></div>
                </div>
                
                <div class="sound-card" id="sound-b">
                    <h3>Sound B</h3>
                    <button onclick="playTripletSound('B')">Play Sound B</button>
                    <div class="params-display" id="params-b"></div>
                </div>
                
                <div class="sound-card" id="sound-x">
                    <h3>Sound X</h3>
                    <button onclick="playTripletSound('X')">Play Sound X</button>
                    <div class="params-display" id="params-x"></div>
                </div>
            </div>
            
            <div class="question">
                Which sound is X more similar to?
            </div>
            
            <div class="choice-buttons">
                <button class="choice-btn" onclick="recordChoice('A')">More like A</button>
                <button class="choice-btn" onclick="recordChoice('B')">More like B</button>
                <button class="choice-btn" onclick="recordABSimilarity()" style="background-color: #9C27B0;">A and B are more similar</button>
                <button class="choice-btn secondary-btn" onclick="cantDecide()" style="background-color: #666;">Can't decide</button>
            </div>
            
        </div>
        
        <!-- Visualization Tab -->
        <div id="visualization-tab" class="tab-content">
            <h2>Timbre Space Visualization</h2>

        <div style="display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 20px; flex-wrap: wrap;">
            <div class="control-group" style="margin: 20px 0;">
                <label for="viz-method">Visualization Method:</label>
                <select id="viz-method" onchange="updateVisualizationMethod()">
                    <option value="mds">Classical MDS</option>
                    <option value="force">Force-Directed</option>
                    <option value="hybrid">Hybrid MDS+Force</option>
                </select>
                <span id="viz-info" style="color: #666; font-size: 12px;"></span>
            </div>
            <div class="button-group">
                <button onclick="updateVisualization()">Update Visualization</button>
            </div>
        </div>


            <div id="force-params" class="control-group" style="margin: 20px 0; display: none;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; max-width: 400px;">
                    <div>
                        <label for="force-iterations">Iterations:</label>
                        <input type="number" id="force-iterations" min="100" max="2000" value="500" step="100"
                               style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <div style="font-size: 12px; color: #666; margin-top: 4px;">100-2000</div>
                    </div>
                    <div>
                        <label for="force-learning-rate">Learning Rate:</label>
                        <input type="number" id="force-learning-rate" min="0.01" max="0.5" value="0.1" step="0.01"
                               style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <div style="font-size: 12px; color: #666; margin-top: 4px;">0.01-0.5</div>
                    </div>
                </div>
                <div style="margin-top: 15px;">
                    <label for="force-initialization">Starting Positions:</label>
                    <select id="force-initialization" style="width: 200px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-left: 10px;">
                        <option value="mds">Initialize with MDS</option>
                        <option value="current">Use Current Positions</option>
                    </select>
                    <div style="font-size: 12px; color: #666; margin-top: 4px;">Choose starting positions for force-directed layout</div>
                </div>
            </div>
            
            <div class="assignment-cards-container">
                <div class="assignment-card" id="assignment-card-a">
                    <div class="assignment-content" id="assignment-content-a">
                        <button class="assignment-btn" onclick="assignPoint('A')" id="assign-a-btn">Use as A</button>
                    </div>
                </div>
                
                <div class="assignment-card" id="assignment-card-b">
                    <div class="assignment-content" id="assignment-content-b">
                        <button class="assignment-btn" onclick="assignPoint('B')" id="assign-b-btn">Use as B</button>
                    </div>
                </div>
                
                <div class="assignment-card" id="assignment-card-x">
                    <div class="assignment-content" id="assignment-content-x">
                        <button class="assignment-btn" onclick="assignPoint('X')" id="assign-x-btn">Use as X</button>
                    </div>
                </div>
            </div>
            
            <div class="assignment-controls" style="text-align: center; margin: 20px 0; display: none;">
                <button class="clear-btn" onclick="clearAssignments()" style="display: none;" id="clear-assignments-btn">Clear All</button>
            </div>
            
            <div class="choice-controls" id="choice-controls" style="display: none;">
                <div class="question" style="margin: 0;">Which sound is X more similar to?</div>
                <button class="choice-btn" onclick="recordVisualizationChoice('A')">More like A</button>
                <button class="choice-btn" onclick="recordVisualizationChoice('B')">More like B</button>
            </div>
            
            <div class="canvas-container">
                <canvas id="scatter-plot"></canvas>
                <div id="loading-overlay" class="loading-overlay">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">
                        Calculating map...<br>
                        <small>This may take a moment</small>
                    </div>
                </div>
            </div>
            <div id="tooltip" class="tooltip"></div>
        </div>
    </div>

    <script>
        // Global variables
        let audioContext;
        let currentTriplet = null;
        let previousTriplet = null; // Store previous triplet for reuse
        let studyData = [];
        let visualizationData = null; // Store visualization data for interactivity
        let normalizedPoints = null; // Store normalized coordinates separately
        let lastTouchedPoint = null; // Track the last clicked point in visualization
        let assignedPoints = { A: null, B: null, X: null }; // Track assigned points
        let currentLayout = null; // Store current layout positions for force-directed continuation
        let currentSoundSet = []; // Track current sound set to detect changes

        // Helper: stable key for a sound using rounding to collapse near-identical FP values
        function soundKey(p) {
            if (!p) return '';
            const round = v => Number(v).toFixed(3); // precision can be tuned
            return `${round(p.carrier)}|${round(p.harmRatio)}|${round(p.modIndex)}`;
        }

        function updateUniqueSoundsCount() {
            const el = document.getElementById('unique-sounds');
            if (!el) return;
            const set = new Set();
            studyData.forEach(tr => {
                ['A','B','X'].forEach(role => {
                    if (tr && tr[role]) set.add(soundKey(tr[role]));
                });
            });
            el.textContent = set.size;
        }

        // Update global stats (data points & unique sounds)
        function updateGlobalStats() {
            const dataCountEl = document.getElementById('data-count');
            if (dataCountEl) dataCountEl.textContent = studyData.length;
            updateUniqueSoundsCount();
        }

        // Initialize audio context
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        // FM Synthesis function
        function playFMSound(carrierFreq, harmRatio, modIndex, duration = 0.5) {
            initAudio();
            
            const now = audioContext.currentTime;
            
            // Create oscillators
            const carrier = audioContext.createOscillator();
            const modulator = audioContext.createOscillator();
            const modulatorGain = audioContext.createGain();
            const masterGain = audioContext.createGain();
            
            // Set frequencies
            carrier.frequency.value = carrierFreq;
            const modFreq = carrierFreq * harmRatio;
            modulator.frequency.value = modFreq;
            
            // Set modulation depth
            modulatorGain.gain.value = modFreq * modIndex;
            
            // Connect FM synthesis chain
            modulator.connect(modulatorGain);
            modulatorGain.connect(carrier.frequency);
            carrier.connect(masterGain);
            masterGain.connect(audioContext.destination);
            
            // Envelope
            masterGain.gain.setValueAtTime(0, now);
            masterGain.gain.linearRampToValueAtTime(0.3, now + 0.01);
            masterGain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            // Start and stop
            carrier.start(now);
            modulator.start(now);
            carrier.stop(now + duration);
            modulator.stop(now + duration);
        }
        
        // Update display values
        document.getElementById('carrier-freq').addEventListener('input', function(e) {
            document.getElementById('carrier-freq-display').textContent = 
                parseFloat(e.target.value).toFixed(2) + ' Hz';
        });
        
        document.getElementById('harm-ratio').addEventListener('input', function(e) {
            document.getElementById('harm-ratio-display').textContent = 
                parseFloat(e.target.value).toFixed(2);
        });
        
        document.getElementById('mod-index').addEventListener('input', function(e) {
            document.getElementById('mod-index-display').textContent = 
                parseFloat(e.target.value).toFixed(2);
        });
        
        // Test sound functions
        function playTestSound() {
            const carrier = parseFloat(document.getElementById('carrier-freq').value);
            const harmRatio = parseFloat(document.getElementById('harm-ratio').value);
            const modIndex = parseFloat(document.getElementById('mod-index').value);
            
            playFMSound(carrier, harmRatio, modIndex);
        }
        
        function randomizeParams() {
            const carrierMin = 73.42;
            const carrierMax = 1174.66;
            const carrier = Math.random() * (carrierMax - carrierMin) + carrierMin;
            const harmRatio = Math.random() * 10;
            const modIndex = Math.random() * 10;
            
            document.getElementById('carrier-freq').value = carrier;
            document.getElementById('harm-ratio').value = harmRatio;
            document.getElementById('mod-index').value = modIndex;
            
            document.getElementById('carrier-freq-display').textContent = carrier.toFixed(2) + ' Hz';
            document.getElementById('harm-ratio-display').textContent = harmRatio.toFixed(2);
            document.getElementById('mod-index-display').textContent = modIndex.toFixed(2);
        }
        
        // Study functions
        function generateRandomParams() {
            return {
                carrier: Math.random() * (1174.66 - 73.42) + 73.42,
                harmRatio: Math.random() * 10,
                modIndex: Math.random() * 10
            };
        }
        
        function generateConstrainedParams(baseParams, variance = 0.3) {
            // Generate parameters within a certain variance from base parameters
            const carrier = baseParams.carrier + (Math.random() - 0.5) * 2 * variance * (1174.66 - 73.42);
            const harmRatio = baseParams.harmRatio + (Math.random() - 0.5) * 2 * variance * 10;
            const modIndex = baseParams.modIndex + (Math.random() - 0.5) * 2 * variance * 10;
            
            // Clamp to valid ranges
            return {
                carrier: Math.max(73.42, Math.min(1174.66, carrier)),
                harmRatio: Math.max(0, Math.min(10, harmRatio)),
                modIndex: Math.max(0, Math.min(10, modIndex))
            };
        }
        
        function generateNewTriplet() {
            let paramsA, paramsB, paramsX;
            let reuseInfo = { isReused: false, position: null, fromPrevious: null };
            
            // If we have a previous triplet, reuse one of its sounds
            if (previousTriplet && Math.random() < 0.8) { // 80% chance to reuse a sound
                // Randomly select which sound from the previous triplet to reuse
                const previousSounds = ['A', 'B', 'X'];
                const selectedPrevious = previousSounds[Math.floor(Math.random() * previousSounds.length)];
                const reuseParams = previousTriplet[selectedPrevious];
                
                // Randomly assign the reused sound to A, B, or X in the new triplet
                const newPositions = ['A', 'B', 'X'];
                const reusePosition = newPositions[Math.floor(Math.random() * newPositions.length)];
                
                console.log(`Reusing sound ${selectedPrevious} from previous triplet as ${reusePosition}`);
                reuseInfo = { isReused: true, position: reusePosition, fromPrevious: selectedPrevious };
                
                // Generate base point for the other sounds
                const baseParams = generateRandomParams();
                
                if (reusePosition === 'A') {
                    paramsA = { ...reuseParams }; // Reuse previous sound
                    paramsB = generateConstrainedParams(baseParams, 0.3);
                    
                    // Generate X closer to either A (reused) or B
                    const closerTo = Math.random() < 0.5 ? paramsA : paramsB;
                    const fartherFrom = closerTo === paramsA ? paramsB : paramsA;
                    const mixRatio = 0.3 + Math.random() * 0.4;
                    paramsX = {
                        carrier: closerTo.carrier * mixRatio + fartherFrom.carrier * (1 - mixRatio),
                        harmRatio: closerTo.harmRatio * mixRatio + fartherFrom.harmRatio * (1 - mixRatio),
                        modIndex: closerTo.modIndex * mixRatio + fartherFrom.modIndex * (1 - mixRatio)
                    };
                    paramsX = generateConstrainedParams(paramsX, 0.1);
                    
                } else if (reusePosition === 'B') {
                    paramsA = generateConstrainedParams(baseParams, 0.3);
                    paramsB = { ...reuseParams }; // Reuse previous sound
                    
                    // Generate X closer to either A or B (reused)
                    const closerTo = Math.random() < 0.5 ? paramsA : paramsB;
                    const fartherFrom = closerTo === paramsA ? paramsB : paramsA;
                    const mixRatio = 0.3 + Math.random() * 0.4;
                    paramsX = {
                        carrier: closerTo.carrier * mixRatio + fartherFrom.carrier * (1 - mixRatio),
                        harmRatio: closerTo.harmRatio * mixRatio + fartherFrom.harmRatio * (1 - mixRatio),
                        modIndex: closerTo.modIndex * mixRatio + fartherFrom.modIndex * (1 - mixRatio)
                    };
                    paramsX = generateConstrainedParams(paramsX, 0.1);
                    
                } else { // reusePosition === 'X'
                    paramsA = generateConstrainedParams(baseParams, 0.3);
                    paramsB = generateConstrainedParams(baseParams, 0.3);
                    paramsX = { ...reuseParams }; // Reuse previous sound as X
                }
                
            } else {
                // Generate completely new triplet (original behavior)
                console.log('Generating completely new triplet');
                
                // Generate base point in parameter space
                const baseParams = generateRandomParams();
                
                // Generate A and B as variations from the base
                paramsA = generateConstrainedParams(baseParams, 0.3);
                paramsB = generateConstrainedParams(baseParams, 0.3);
                
                // Generate X as either closer to A or B (randomly)
                const closerTo = Math.random() < 0.5 ? paramsA : paramsB;
                const fartherFrom = closerTo === paramsA ? paramsB : paramsA;
                
                // X is generated to be somewhat between A and B, but closer to one
                const mixRatio = 0.3 + Math.random() * 0.4; // Between 0.3 and 0.7
                paramsX = {
                    carrier: closerTo.carrier * mixRatio + fartherFrom.carrier * (1 - mixRatio),
                    harmRatio: closerTo.harmRatio * mixRatio + fartherFrom.harmRatio * (1 - mixRatio),
                    modIndex: closerTo.modIndex * mixRatio + fartherFrom.modIndex * (1 - mixRatio)
                };
                
                // Add some noise to X
                paramsX = generateConstrainedParams(paramsX, 0.1);
            }
            
            currentTriplet = {
                A: paramsA,
                B: paramsB,
                X: paramsX,
                timestamp: new Date().toISOString(),
                reuseInfo: reuseInfo // Store reuse information
            };
            
            // Update display
            updateParamsDisplay('A', currentTriplet.A, reuseInfo.position === 'A' ? reuseInfo.fromPrevious : null);
            updateParamsDisplay('B', currentTriplet.B, reuseInfo.position === 'B' ? reuseInfo.fromPrevious : null);
            updateParamsDisplay('X', currentTriplet.X, reuseInfo.position === 'X' ? reuseInfo.fromPrevious : null);
            
            // Reset active states
            document.querySelectorAll('.sound-card').forEach(card => {
                card.classList.remove('active');
            });
        }
        
        function updateParamsDisplay(sound, params, reuseFromPrevious = null) {
            const display = document.getElementById(`params-${sound.toLowerCase()}`);
            let reuseIndicator = '';
            if (reuseFromPrevious) {
                reuseIndicator = `<div style="color: #FF9800; font-weight: bold; margin-bottom: 5px; font-size: 11px;">â†» Reused from ${reuseFromPrevious}</div>`;
            }
            display.innerHTML = `
                ${reuseIndicator}
                Carrier: ${params.carrier.toFixed(1)} Hz<br>
                Harm Ratio: ${params.harmRatio.toFixed(2)}<br>
                Mod Index: ${params.modIndex.toFixed(2)}
            `;
        }
        
        function playTripletSound(sound) {
            if (!currentTriplet) {
                generateNewTriplet();
            }
            
            const params = currentTriplet[sound];
            playFMSound(params.carrier, params.harmRatio, params.modIndex);
            
            // Update active state
            document.querySelectorAll('.sound-card').forEach(card => {
                card.classList.remove('active');
            });
            document.getElementById(`sound-${sound.toLowerCase()}`).classList.add('active');
        }
        
        function recordChoice(choice) {
            if (!currentTriplet) {
                alert('Please generate a triplet first!');
                return;
            }
            
            const trialData = {
                ...currentTriplet,
                choice: choice,
                responseTime: new Date().toISOString()
            };
            
            studyData.push(trialData);
            localStorage.setItem('fmSynthStudyData', JSON.stringify(studyData));
            
            // Update global stats
            updateGlobalStats();
            
            // Store current triplet as previous before generating new one
            previousTriplet = { ...currentTriplet };
            
            // Generate new triplet
            generateNewTriplet();
            
            // Flash feedback
            const chosenCard = document.getElementById(`sound-${choice.toLowerCase()}`);
            chosenCard.style.backgroundColor = '#4CAF50';
            setTimeout(() => {
                chosenCard.style.backgroundColor = '#f8f9fa';
            }, 300);
        }

        function recordABSimilarity() {
            if (!currentTriplet) {
                alert('Please generate a triplet first!');
                return;
            }
            
            // Create the transformed triplet where A becomes X and X becomes A
            // This represents the judgment that A and B are more similar to each other than X is to either
            const transformedTriplet = {
                A: currentTriplet.X,  // X becomes the new A
                B: currentTriplet.B,  // B stays the same
                X: currentTriplet.A,  // A becomes the new X
                timestamp: new Date().toISOString(),
                originalTriplet: { ...currentTriplet }, // Keep reference to original for debugging
                transformationType: 'AB_similarity'
            };
            
            // Record the judgment that (new) X is more similar to B than to A
            // This captures the user's judgment that A and B were more similar to each other
            const trialData = {
                ...transformedTriplet,
                choice: 'B',  // In the transformed triplet, X (original A) is judged closer to B
                responseTime: new Date().toISOString(),
                originalChoice: 'AB_similarity'  // Track that this came from the AB similarity button
            };
            
            studyData.push(trialData);
            localStorage.setItem('fmSynthStudyData', JSON.stringify(studyData));
            
            // Update global stats
            updateGlobalStats();
            
            // Store current triplet as previous before generating new one
            previousTriplet = { ...currentTriplet };
            
            // Generate new triplet
            generateNewTriplet();
            
            // Flash feedback on both A and B cards to show they were judged as similar
            const cardA = document.getElementById('sound-a');
            const cardB = document.getElementById('sound-b');
            
            cardA.style.backgroundColor = '#9C27B0';
            cardB.style.backgroundColor = '#9C27B0';
            
            setTimeout(() => {
                cardA.style.backgroundColor = '#f8f9fa';
                cardB.style.backgroundColor = '#f8f9fa';
            }, 300);
        }

        // User could not decide: flash all three cards gray then generate a new triplet (no data recorded)
        function cantDecide() {
            if (!currentTriplet) {
                generateNewTriplet();
                return;
            }
            // Preserve current triplet for possible reuse logic
            previousTriplet = { ...currentTriplet };
            const cards = ['sound-a','sound-b','sound-x'].map(id => document.getElementById(id));
            cards.forEach(card => {
                if (card) card.style.backgroundColor = '#666';
            });
            setTimeout(() => {
                cards.forEach(card => {
                    if (card) card.style.backgroundColor = '#f8f9fa';
                });
                generateNewTriplet();
            }, 300);
        }

        async function computeEmbedding(distanceMatrix, method = 'mds') {
            const n = distanceMatrix.length;
            
            if (n < 2) {
                return [[0, 0]];
            }
            
            try {
                let result;
                switch(method) {
                    case 'mds':
                        result = classicalMDS(distanceMatrix);
                        // Store current layout for future use
                        currentLayout = result.map(pos => [pos[0], pos[1]]);
                        return result;
                    case 'force':
                        // Get user-specified parameters
                        const iterations = parseInt(document.getElementById('force-iterations')?.value) || 500;
                        const learningRate = parseFloat(document.getElementById('force-learning-rate')?.value) || 0.1;
                        const initialization = document.getElementById('force-initialization')?.value || 'mds';
                        return forceDirectedLayout(distanceMatrix, iterations, { learningRate, initialization });
                    case 'hybrid':
                        result = hybridEmbedding(distanceMatrix);
                        // Store current layout for future use
                        currentLayout = result.map(pos => [pos[0], pos[1]]);
                        return result;
                    default:
                        result = classicalMDS(distanceMatrix);
                        // Store current layout for future use
                        currentLayout = result.map(pos => [pos[0], pos[1]]);
                        return result;
                }
            } catch (error) {
                console.error(`Error with ${method} method:`, error);
                console.warn('Falling back to Classical MDS');
                const fallbackResult = classicalMDS(distanceMatrix);
                // Store current layout for future use
                currentLayout = fallbackResult.map(pos => [pos[0], pos[1]]);
                return fallbackResult;
            }
        }

        // Enhanced force-directed layout with better parameters
        function forceDirectedLayout(distanceMatrix, iterations = 500, options = {}) {
            const n = distanceMatrix.length;
            
            if (n < 2) {
                return [[0, 0]];
            }
            
            // Default options
            const opts = {
                attractionStrength: 0.5,
                repulsionStrength: 0.5,
                learningRate: 0.1,
                initialization: 'mds',
                ...options
            };
            
            // Initialize positions with more spread
            let positions = Array(n).fill(0).map(() => [
                (Math.random() - 0.5) * 4, // Larger initial spread
                (Math.random() - 0.5) * 4
            ]);
            
            // Choose initialization method based on user preference
            if (opts.initialization === 'current' && currentLayout && currentLayout.length === n) {
                // Use current layout positions
                console.log('Using current positions for force-directed initialization');
                positions = currentLayout.map(pos => [pos[0], pos[1]]);
            } else {
                // Try to initialize with MDS (default behavior)
                try {
                    const mdsPositions = classicalMDS(distanceMatrix);
                    if (mdsPositions && mdsPositions.length === n) {
                        // Scale MDS positions to ensure good initial spread
                        const xCoords = mdsPositions.map(p => p[0]);
                        const yCoords = mdsPositions.map(p => p[1]);
                        const xRange = Math.max(...xCoords) - Math.min(...xCoords);
                        const yRange = Math.max(...yCoords) - Math.min(...yCoords);
                        
                        if (xRange > 0.001 && yRange > 0.001) {
                            positions = mdsPositions.map(pos => [pos[0], pos[1]]);
                            console.log('Using MDS positions for force-directed initialization');
                        }
                    }
                } catch (e) {
                    console.log('MDS initialization failed for force-directed, using random positions');
                }
            }
            
            // Parameters
            let learningRate = opts.learningRate;
            
            for (let iter = 0; iter < iterations; iter++) {
                const forces = positions.map(() => [0, 0]);
                
                // Calculate forces between all pairs
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        const dx = positions[i][0] - positions[j][0];
                        const dy = positions[i][1] - positions[j][1];
                        const currentDist = Math.sqrt(dx * dx + dy * dy) || 0.001;
                        const targetDist = distanceMatrix[i][j] || 0.1;
                        
                        // Ensure target distance is reasonable
                        const clampedTargetDist = Math.max(0.01, Math.min(5.0, targetDist));
                        
                        // Spring force proportional to distance error
                        const error = currentDist - clampedTargetDist;
                        const forceStrength = error * learningRate;
                        
                        // Unit vector from j to i
                        const unitX = dx / currentDist;
                        const unitY = dy / currentDist;
                        
                        // Apply force (attractive if too far, repulsive if too close)
                        const fx = unitX * forceStrength;
                        const fy = unitY * forceStrength;
                        
                        forces[i][0] -= fx;
                        forces[i][1] -= fy;
                        forces[j][0] += fx;
                        forces[j][1] += fy;
                    }
                }
                
                // Apply forces with dampening
                const dampening = 0.95;
                for (let i = 0; i < n; i++) {
                    // Check for invalid forces
                    if (isNaN(forces[i][0]) || isNaN(forces[i][1])) {
                        forces[i][0] = 0;
                        forces[i][1] = 0;
                    }
                    
                    // Apply with dampening
                    positions[i][0] += forces[i][0] * dampening;
                    positions[i][1] += forces[i][1] * dampening;
                    
                    // Check for invalid positions
                    if (isNaN(positions[i][0]) || isNaN(positions[i][1])) {
                        positions[i][0] = (Math.random() - 0.5) * 2;
                        positions[i][1] = (Math.random() - 0.5) * 2;
                    }
                }
                
                // Adaptive learning rate
                if (iter % 100 === 0) {
                    learningRate *= 0.999;
                }
            }
            
            // Ensure we have valid final positions
            const validPositions = positions.map(pos => [
                isNaN(pos[0]) ? Math.random() - 0.5 : pos[0],
                isNaN(pos[1]) ? Math.random() - 0.5 : pos[1]
            ]);
            
            // Store current layout for future use
            currentLayout = validPositions.map(pos => [pos[0], pos[1]]);
            
            console.log('Force-directed layout completed with', n, 'points');
            console.log('Final position ranges:', {
                x: [Math.min(...validPositions.map(p => p[0])), Math.max(...validPositions.map(p => p[0]))],
                y: [Math.min(...validPositions.map(p => p[1])), Math.max(...validPositions.map(p => p[1]))]
            });
            
            return validPositions;
        }

        // Hybrid approach: combine multiple embeddings
        function hybridEmbedding(distanceMatrix) {
            // Get embeddings from different methods
            const mdsCoords = classicalMDS(distanceMatrix);
            const forceCoords = forceDirectedLayout(distanceMatrix, 200);
            
            // Weight towards MDS for global structure, force-directed for local
            const alpha = 0.7; // MDS weight
            const combined = mdsCoords.map((mds, i) => [
                alpha * mds[0] + (1 - alpha) * forceCoords[i][0],
                alpha * mds[1] + (1 - alpha) * forceCoords[i][1]
            ]);
            
            return combined;
        }

    // Visualization controls are now static in HTML (previously injected dynamically)
        // Update visualization method based on selection
        function updateVisualizationMethod() {
            const method = document.getElementById('viz-method').value;
            const info = document.getElementById('viz-info');
            const forceParams = document.getElementById('force-params');
            const initSelect = document.getElementById('force-initialization');
            
            // Show/hide force-directed parameters
            if (forceParams) {
                forceParams.style.display = method === 'force' ? 'block' : 'none';
            }
            
            // Update initialization option availability
            if (initSelect && method === 'force') {
                const currentOption = initSelect.querySelector('option[value="current"]');
                if (currentOption) {
                    if (!currentLayout || currentLayout.length === 0) {
                        currentOption.disabled = true;
                        currentOption.textContent = 'Use Current Positions (not available)';
                        // If current was selected but not available, switch to MDS
                        if (initSelect.value === 'current') {
                            initSelect.value = 'mds';
                        }
                    } else {
                        currentOption.disabled = false;
                        currentOption.textContent = 'Use Current Positions';
                    }
                }
            }
            
            switch(method) {
                case 'mds':
                    info.textContent = 'Using Classical MDS for visualization.';
                    break;
                case 'force':
                    const initMethod = initSelect ? initSelect.value : 'mds';
                    const initText = initMethod === 'current' && currentLayout ? 
                        ' (continuing from current positions)' : ' (starting from MDS)';
                    info.textContent = `Using Force-Directed layout for visualization${initText}.`;
                    break;
                case 'hybrid':
                    info.textContent = 'Using Hybrid MDS + Force-Directed layout for visualization.';
                    break;
                default:
                    info.textContent = '';
                    break;
            }
            
            info.style.color = '#666';
            // updateVisualization();
        }

        // Visualization functions
        function computeSimilarityMatrix() {
            const sounds = new Map();
            const soundsList = [];
            
            // Collect all unique sounds
            studyData.forEach(trial => {
                ['A', 'B', 'X'].forEach(key => {
                    const hash = JSON.stringify(trial[key]);
                    if (!sounds.has(hash)) {
                        const sound = {
                            params: trial[key],
                            hash: hash,
                            index: soundsList.length
                        };
                        sounds.set(hash, sound);
                        soundsList.push(sound);
                    }
                });
            });
            
            // Check if sound set has changed - if so, reset current layout
            const newSoundHashes = soundsList.map(s => s.hash).sort();
            const currentSoundHashes = currentSoundSet.map(s => s.hash).sort();
            
            if (newSoundHashes.length !== currentSoundHashes.length || 
                !newSoundHashes.every((hash, i) => hash === currentSoundHashes[i])) {
                console.log('Sound set changed, resetting current layout');
                currentLayout = null;
                currentSoundSet = soundsList.map(s => ({ ...s })); // Deep copy
            }
            
            const n = soundsList.length;
            const distanceMatrix = Array(n).fill(0).map(() => Array(n).fill(0));
            
            // Initialize with parameter-based distances
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const p1 = soundsList[i].params;
                    const p2 = soundsList[j].params;
                    
                    // Normalize and calculate Euclidean distance
                    const carrierDist = (p1.carrier - p2.carrier) / (1174.66 - 73.42);
                    const harmDist = (p1.harmRatio - p2.harmRatio) / 10;
                    const modDist = (p1.modIndex - p2.modIndex) / 10;
                    
                    const dist = Math.sqrt(carrierDist ** 2 + harmDist ** 2 + modDist ** 2);
                    distanceMatrix[i][j] = dist;
                    distanceMatrix[j][i] = dist;
                }
            }
            
            // Adjust distances based on similarity judgments
            studyData.forEach(trial => {
                const aIdx = sounds.get(JSON.stringify(trial.A)).index;
                const bIdx = sounds.get(JSON.stringify(trial.B)).index;
                const xIdx = sounds.get(JSON.stringify(trial.X)).index;
                
                // Stronger weight for visualization-based judgments
                const isVisualizationJudgment = trial.source === 'visualization';
                const similarityAdjustment = isVisualizationJudgment ? -1 : -0.1;  // Subtract from distance (make closer)
                const dissimilarityAdjustment = isVisualizationJudgment ? 1 : 0.1;  // Add to distance (make farther)
                
                if (trial.choice === 'A') {
                    // X is more similar to A than to B
                    distanceMatrix[xIdx][aIdx] += similarityAdjustment;
                    distanceMatrix[aIdx][xIdx] += similarityAdjustment;
                    distanceMatrix[xIdx][bIdx] += dissimilarityAdjustment;
                    distanceMatrix[bIdx][xIdx] += dissimilarityAdjustment;
                } else {
                    // X is more similar to B than to A
                    distanceMatrix[xIdx][bIdx] += similarityAdjustment;
                    distanceMatrix[bIdx][xIdx] += similarityAdjustment;
                    distanceMatrix[xIdx][aIdx] += dissimilarityAdjustment;
                    distanceMatrix[aIdx][xIdx] += dissimilarityAdjustment;
                }
                
                // Ensure distances don't go negative
                const minDistance = 0.002; // Minimum distance to avoid zero
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        distanceMatrix[i][j] = Math.max(minDistance, distanceMatrix[i][j]);
                    }
                }
            });
            
            return { sounds: soundsList, distanceMatrix };
        }
        
        // Proper MDS implementation using ML-Matrix library
        function classicalMDS(distanceMatrix) {
            const n = distanceMatrix.length;
            
            if (n < 2) {
                return [[0, 0]];
            }
            
            // Check for ML-Matrix library with multiple possible global names
            const MLLib = window.MLMatrix || window.mlMatrix || window.ML;
            
            if (!MLLib) {
                console.warn('ML-Matrix library not available');
                console.warn('Checked for: MLMatrix, mlMatrix, ML');
                console.warn('Available globals:', Object.keys(window).filter(k => k.toLowerCase().includes('matrix')));
                console.warn('Using fallback MDS implementation...');
                return fallbackMDS(distanceMatrix);
            }
            
            try {
                // console.log('âœ… Using ML-Matrix library for MDS calculation');
                // console.log('Library object:', MLLib);
                // console.log('Available components:', Object.keys(MLLib));
                
                // Try to access Matrix and EigenvalueDecomposition
                const Matrix = MLLib.Matrix || MLLib.default?.Matrix;
                const EigenvalueDecomposition = MLLib.EigenvalueDecomposition || MLLib.EVD || MLLib.default?.EigenvalueDecomposition;
                
                if (!Matrix) {
                    throw new Error('Matrix class not found in ML library');
                }
                if (!EigenvalueDecomposition) {
                    throw new Error('EigenvalueDecomposition class not found in ML library');
                }
                
                // console.log('âœ… Found Matrix and EigenvalueDecomposition classes');
                
                // Create squared distance matrix
                const D2 = new Matrix(n, n);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        D2.set(i, j, distanceMatrix[i][j] * distanceMatrix[i][j]);
                    }
                }
                
                // Double centering matrix
                const rowMeans = new Array(n);
                let grandMean = 0;
                
                // Calculate row means
                for (let i = 0; i < n; i++) {
                    let sum = 0;
                    for (let j = 0; j < n; j++) {
                        sum += D2.get(i, j);
                    }
                    rowMeans[i] = sum / n;
                    grandMean += rowMeans[i];
                }
                grandMean /= n;
                
                // Create centered matrix B
                const B = new Matrix(n, n);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        B.set(i, j, -0.5 * (D2.get(i, j) - rowMeans[i] - rowMeans[j] + grandMean));
                    }
                }
                
                // Eigenvalue decomposition
                const evd = new EigenvalueDecomposition(B);
                const eigenVectors = evd.eigenvectorMatrix;
                const eigenValues = evd.realEigenvalues;
                
                // Sort eigenvalues and eigenvectors in descending order
                const sortedIndices = eigenValues
                    .map((val, idx) => ({ val, idx }))
                    .sort((a, b) => b.val - a.val)
                    .map(item => item.idx);
                
                // Take the first 2 eigenvectors (corresponding to largest eigenvalues)
                const coords = [];
                for (let i = 0; i < n; i++) {
                    const x = eigenVectors.get(i, sortedIndices[0]) * Math.sqrt(Math.max(0, eigenValues[sortedIndices[0]]));
                    const y = eigenVectors.get(i, sortedIndices[1]) * Math.sqrt(Math.max(0, eigenValues[sortedIndices[1]]));
                    coords.push([x, y]);
                }
                
                console.log('âœ… MDS calculation successful using ML-Matrix');
                return coords;
                
            } catch (error) {
                console.warn('âŒ MDS calculation failed with ML-Matrix:', error.message);
                console.warn('Error details:', error);
                console.warn('Falling back to simple force-directed layout');
                return fallbackMDS(distanceMatrix);
            }
        }
        
        // Fallback MDS implementation when ML-Matrix is not available
        function fallbackMDS(distanceMatrix) {
            const n = distanceMatrix.length;
            
            // Use a simple force-directed layout as fallback
            // Initialize random positions
            const coords = [];
            for (let i = 0; i < n; i++) {
                coords.push([Math.random() - 0.5, Math.random() - 0.5]);
            }
            
            // Simple iterative improvement
            for (let iter = 0; iter < 100; iter++) {
                const forces = coords.map(() => [0, 0]);
                
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        const dx = coords[i][0] - coords[j][0];
                        const dy = coords[i][1] - coords[j][1];
                        const currentDist = Math.sqrt(dx * dx + dy * dy) || 0.001;
                        const targetDist = distanceMatrix[i][j];
                        
                        const error = (currentDist - targetDist) / targetDist;
                        const force = error * 0.1;
                        
                        const fx = (dx / currentDist) * force;
                        const fy = (dy / currentDist) * force;
                        
                        forces[i][0] -= fx;
                        forces[i][1] -= fy;
                        forces[j][0] += fx;
                        forces[j][1] += fy;
                    }
                }
                
                // Apply forces
                for (let i = 0; i < n; i++) {
                    coords[i][0] += forces[i][0];
                    coords[i][1] += forces[i][1];
                }
            }
            
            return coords;
        }
        
        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            const canvas = document.getElementById('scatter-plot');
            
            if (!container || !canvas) return;
            
            // Get container width
            const containerWidth = container.clientWidth;
            
            // Set canvas size maintaining aspect ratio
            const aspectRatio = 4/3; // 800x600 aspect ratio
            const canvasWidth = Math.min(containerWidth, 800);
            const canvasHeight = canvasWidth / aspectRatio;
            
            // Set both CSS size and actual canvas size
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // If we have normalized points, just rescale them without recalculating
            if (normalizedPoints) {
                rescalePoints();
            }
        }
        
        function rescalePoints() {
            const canvas = document.getElementById('scatter-plot');
            const ctx = canvas.getContext('2d');
            
            // Hide loading overlay if it's visible
            hideLoadingOverlay();
            
            // Responsive margins
            const marginRatio = 0.05; // 5% margin
            const margin = Math.min(canvas.width, canvas.height) * marginRatio;
            
            // Calculate title font size to reserve space for it
            const titleFontSize = Math.max(14, Math.min(18, canvas.width / 40));
            const titleSpace = titleFontSize + 10; // Title height plus some padding
            
            // Adjust drawing area to leave space for title at top
            const topMargin = margin + titleSpace;
            const sideMargin = margin;
            const bottomMargin = margin;
            
            const width = canvas.width - 2 * sideMargin;
            const height = canvas.height - topMargin - bottomMargin;
            
            // Responsive point size
            const baseRadius = Math.min(canvas.width, canvas.height) / 100;
            const radius = Math.max(6, Math.min(12, baseRadius));
            
            // Rescale existing normalized points to new canvas dimensions
            const points = normalizedPoints.map(np => ({
                x: sideMargin + np.normalizedX * width,
                y: topMargin + np.normalizedY * height,
                color: np.color,
                params: np.params,
                radius: radius,
                highlighted: false
            }));
            
            // Update visualization data
            visualizationData = { points, canvas, ctx };
            
            // Redraw
            drawVisualization();
        }
        
        // Helper functions for loading overlay
        function showLoadingOverlay() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                overlay.classList.add('visible');
            }
        }
        
        function hideLoadingOverlay() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                overlay.classList.remove('visible');
            }
        }
        
        function updateVisualization() {
            const canvas = document.getElementById('scatter-plot');
            const ctx = canvas.getContext('2d');
            const method = document.getElementById('viz-method')?.value || 'mds';
            
            // Show loading overlay
            showLoadingOverlay();
            
            // Use setTimeout to allow the loading overlay to render before starting computation
            setTimeout(async () => {
                try {
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    if (studyData.length === 0) {
                        ctx.fillStyle = '#666';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('No data yet. Complete some trials first!', canvas.width / 2, canvas.height / 2);
                        normalizedPoints = null;
                        hideLoadingOverlay();
                        return;
                    }
                    
                    // Compute similarity matrix and apply MDS
                    const { sounds, distanceMatrix } = computeSimilarityMatrix();

                    // Apply selected embedding method
                    const coords = await computeEmbedding(distanceMatrix, method);
                    
                    
                    if (sounds.length < 3) {
                        ctx.fillStyle = '#666';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('Need at least 3 different sounds. Keep collecting data!', canvas.width / 2, canvas.height / 2);
                        normalizedPoints = null;
                        hideLoadingOverlay();
                        return;
                    }
                    
                    // Normalize coordinates to 0-1 range and store them
                    const xCoords = coords.map(p => p[0]);
                    const yCoords = coords.map(p => p[1]);
                    const xMin = Math.min(...xCoords);
                    const xMax = Math.max(...xCoords);
                    const yMin = Math.min(...yCoords);
                    const yMax = Math.max(...yCoords);
                    
                    console.log(`Coordinate ranges for ${method}:`, {
                        x: [xMin, xMax],
                        y: [yMin, yMax],
                        xRange: xMax - xMin,
                        yRange: yMax - yMin
                    });
                    
                    // Ensure we have valid ranges for normalization
                    const xRange = xMax - xMin;
                    const yRange = yMax - yMin;
                    const minRange = 0.001; // Minimum range to avoid division by zero
                    
                    const normalizeX = xRange > minRange ? xRange : 1;
                    const normalizeY = yRange > minRange ? yRange : 1;
                    
                    // Store normalized points (0-1 range) for future resizing
                    normalizedPoints = coords.map((coord, i) => {
                        const normalizedX = xRange > minRange ? (coord[0] - xMin) / normalizeX : 0.5;
                        const normalizedY = yRange > minRange ? (coord[1] - yMin) / normalizeY : 0.5;
                        
                        // Color based on synth parameters mapped to RGB
                        // Convert frequency to MIDI pitch: MIDI = 12 * log2(freq/440) + 69
                        const midiPitch = 12 * Math.log2(sounds[i].params.carrier / 440) + 69;
                        // Map MIDI pitch range 38-86 to Red channel (0-230)
                        const red = Math.round(Math.max(0, Math.min(230, ((midiPitch - 38) / (86 - 38)) * 230)));
                        
                        // Map Harmonicity Ratio 0-10 to Green channel (0-230)
                        const green = Math.round((sounds[i].params.harmRatio / 10) * 230);
                        
                        // Map Modulation Index 0-10 to Blue channel (0-230)
                        const blue = Math.round((sounds[i].params.modIndex / 10) * 230);
                        
                        const color = `rgb(${red}, ${green}, ${blue})`;
                        
                        return {
                            normalizedX,
                            normalizedY,
                            color,
                            params: sounds[i].params
                        };
                    });
                    
                    // Now scale to current canvas size
                    rescalePoints();
                    
                    // Update stats
                    document.getElementById('data-count').textContent = studyData.length;
                    document.getElementById('unique-sounds').textContent = sounds.length;
                    
                    // Update info text with more details for force-directed method
                    const info = document.getElementById('viz-info');
                    if (info) {
                        let infoText = `${sounds.length} sounds embedded using ${method.toUpperCase()}`;
                        if (method === 'force') {
                            const initMethod = document.getElementById('force-initialization')?.value || 'mds';
                            const initText = initMethod === 'current' && currentLayout ? 
                                ' (continued from current positions)' : ' (started from MDS)';
                            infoText += initText;
                        }
                        info.textContent = infoText;
                    }
                    
                    // Update initialization option availability
                    const initSelect = document.getElementById('force-initialization');
                    if (initSelect && method === 'force') {
                        const currentOption = initSelect.querySelector('option[value="current"]');
                        if (currentOption) {
                            if (!currentLayout || currentLayout.length === 0) {
                                currentOption.disabled = true;
                                currentOption.textContent = 'Use Current Positions (not available)';
                            } else {
                                currentOption.disabled = false;
                                currentOption.textContent = 'Use Current Positions';
                            }
                        }
                    }
                    
                } catch (error) {
                    console.error('Error updating visualization:', error);
                    ctx.fillStyle = '#666';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Error updating visualization. Please try again.', canvas.width / 2, canvas.height / 2);
                } finally {
                    // Always hide loading overlay
                    hideLoadingOverlay();
                }
            }, 50); // Small delay to ensure loading overlay renders
        }
        
        function drawVisualization() {
            if (!visualizationData) return;
            
            const { points, canvas, ctx } = visualizationData;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate responsive sizes
            const margin = Math.min(canvas.width, canvas.height) * 0.05;
            const fontSize = Math.max(12, Math.min(16, canvas.width / 50));
            const titleFontSize = Math.max(14, Math.min(18, canvas.width / 40));
            
            // Draw points
            points.forEach((point) => {
                // Draw shadow for highlighted points
                if (point.highlighted) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.beginPath();
                    ctx.arc(point.x + 2, point.y + 2, point.radius + 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Draw point
                ctx.fillStyle = point.color;
                ctx.strokeStyle = point.highlighted ? '#fff' : '#333';
                ctx.lineWidth = point.highlighted ? 3 : 1;
                ctx.beginPath();
                ctx.arc(point.x, point.y, point.radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            });
            
            // Draw assignment labels for A, B, X points
            const labelFontSize = Math.max(10, Math.min(14, canvas.width / 60));
            ctx.font = `bold ${labelFontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            points.forEach((point) => {
                // Check if this point matches any assigned point
                let assignmentLabel = null;
                
                ['A', 'B', 'X'].forEach(role => {
                    if (assignedPoints[role] && 
                        Math.abs(assignedPoints[role].params.carrier - point.params.carrier) < 0.1 &&
                        Math.abs(assignedPoints[role].params.harmRatio - point.params.harmRatio) < 0.01 &&
                        Math.abs(assignedPoints[role].params.modIndex - point.params.modIndex) < 0.01) {
                        assignmentLabel = role;
                    }
                });
                
                if (assignmentLabel) {
                    // Draw label background
                    const labelOffset = point.radius + 8;
                    const labelX = point.x;
                    const labelY = point.y - labelOffset;
                    
                    // Background circle for label
                    ctx.fillStyle = assignmentLabel === 'A' ? '#FF5722' : 
                                   assignmentLabel === 'B' ? '#2196F3' : '#FF9800';
                    ctx.beginPath();
                    ctx.arc(labelX, labelY, labelFontSize * 0.8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Label border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Label text
                    ctx.fillStyle = '#fff';
                    ctx.fillText(assignmentLabel, labelX, labelY);
                }
            });
            
            // Title
            ctx.fillStyle = '#333';
            ctx.font = `${titleFontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('Perceptual Timbre Space', canvas.width / 2, margin);
        }
        
        // Interactive canvas functions
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }
        
        function findPointAt(x, y) {
            if (!visualizationData) return null;
            
            const { points } = visualizationData;
            
            for (let i = points.length - 1; i >= 0; i--) {
                const point = points[i];
                const dx = x - point.x;
                const dy = y - point.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist <= point.radius + 2) {
                    return point;
                }
            }
            
            return null;
        }
        
        // Set up canvas interactivity
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize assignment display
            updateAssignmentDisplay();

            // Hook up visualization control listeners (moved from dynamic insertion)
            const iterationsInput = document.getElementById('force-iterations');
            const learningRateInput = document.getElementById('force-learning-rate');
            const initializationSelect = document.getElementById('force-initialization');
            [iterationsInput, learningRateInput, initializationSelect].forEach(el => {
                if (!el) return;
                el.addEventListener('change', () => {
                    const methodSel = document.getElementById('viz-method');
                    if (methodSel && methodSel.value === 'force') {
                        // updateVisualization();
                    }
                });
            });
            // Initialize method info text
            if (document.getElementById('viz-method')) {
                updateVisualizationMethod();
            }
            
            const canvas = document.getElementById('scatter-plot');
            const tooltip = document.getElementById('tooltip');
            let hoveredPoint = null;
            
            canvas.addEventListener('mousemove', function(evt) {
                const pos = getMousePos(canvas, evt);
                const point = findPointAt(pos.x, pos.y);
                
                if (point !== hoveredPoint) {
                    // Update hover state
                    if (hoveredPoint) {
                        hoveredPoint.highlighted = false;
                    }
                    
                    hoveredPoint = point;
                    
                    if (point) {
                        point.highlighted = true;
                        
                        // Show tooltip
                        const rect = canvas.getBoundingClientRect();
                        tooltip.innerHTML = `
                            <div class="tooltip-title">FM Synth Parameters</div>
                            <div class="tooltip-param">
                                <span class="tooltip-label">Carrier:</span>
                                <span class="tooltip-value">${point.params.carrier.toFixed(1)} Hz</span>
                            </div>
                            <div class="tooltip-param">
                                <span class="tooltip-label">Harm Ratio:</span>
                                <span class="tooltip-value">${point.params.harmRatio.toFixed(2)}</span>
                            </div>
                            <div class="tooltip-param">
                                <span class="tooltip-label">Mod Index:</span>
                                <span class="tooltip-value">${point.params.modIndex.toFixed(2)}</span>
                            </div>
                        `;
                        
                        // Position tooltip closer to the point
                        const tooltipX = rect.left + point.x + window.scrollX;
                        const tooltipY = rect.top + point.y + window.scrollY - 15; // Much closer to the point
                        
                        // Get tooltip dimensions
                        tooltip.style.display = 'block';
                        const tooltipRect = tooltip.getBoundingClientRect();
                        tooltip.style.display = '';
                        
                        // Adjust position to keep tooltip on screen
                        let finalX = tooltipX - tooltipRect.width / 2;
                        let finalY = tooltipY - tooltipRect.height;
                        
                        // Keep tooltip within viewport
                        if (finalX < 5) finalX = 5;

                        if (finalX + tooltipRect.width > window.innerWidth - 5) {
                            finalX = window.innerWidth - tooltipRect.width - 5;
                        }
                        
                        // If tooltip would go above viewport, show it below the point instead
                        if (finalY < 5) {
                            finalY = tooltipY + point.radius + 15;
                            // Flip the arrow
                            tooltip.style.setProperty('--arrow-direction', 'top');
                        } else {
                            tooltip.style.setProperty('--arrow-direction', 'bottom');
                        }
                        
                        tooltip.style.left = finalX + 'px';
                        tooltip.style.top = finalY + 'px';
                        tooltip.classList.add('visible');
                        
                        canvas.style.cursor = 'pointer';
                    } else {
                        tooltip.classList.remove('visible');
                        canvas.style.cursor = 'crosshair';
                    }
                    
                    drawVisualization();
                }
            });
            
            canvas.addEventListener('mouseleave', function() {
                if (hoveredPoint) {
                    hoveredPoint.highlighted = false;
                    hoveredPoint = null;
                    drawVisualization();
                }
                tooltip.classList.remove('visible');
            });
            
            canvas.addEventListener('click', function(evt) {
                const pos = getMousePos(canvas, evt);
                const point = findPointAt(pos.x, pos.y);
                
                if (point) {
                    // Store last touched point
                    lastTouchedPoint = point;
                    
                    // Play the sound
                    playFMSound(point.params.carrier, point.params.harmRatio, point.params.modIndex);
                    
                    // Visual feedback
                    const originalRadius = point.radius;
                    point.radius = 12;
                    drawVisualization();
                    
                    // Show indicator for last touched point
                    showLastTouchedIndicator(point);
                    
                    setTimeout(() => {
                        point.radius = originalRadius;
                        drawVisualization();
                    }, 200);
                }
            });
        });
        
        // Tab switching
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // // Update visualization if switching to that tab
            // if (tabName === 'visualization') {
            //     updateVisualization();
            // }
        }
        
        // Data management
        function clearAllData() {
            // Show confirmation dialog
            const confirmed = confirm(
                'Are you sure you want to clear all data?\n\n' +
                'This will permanently remove:\n' +
                'â€¢ All study trial data\n' +
                'â€¢ The visualization map\n' +
                'â€¢ Any assigned points\n\n' +
                'This action cannot be undone.'
            );
            
            if (!confirmed) {
                return;
            }
            
            // Clear all data
            studyData = [];
            visualizationData = null;
            normalizedPoints = null;
            lastTouchedPoint = null;
            currentLayout = null; // Clear stored layout positions
            currentSoundSet = []; // Clear tracked sound set
            previousTriplet = null; // Clear previous triplet
            
            // Clear assignments
            assignedPoints = { A: null, B: null, X: null };
            
            // Clear localStorage
            localStorage.removeItem('fmSynthStudyData');
            
            // Update UI elements
            document.getElementById('data-count').textContent = '0';
            document.getElementById('unique-sounds').textContent = '0';
            
            // Clear the canvas
            const canvas = document.getElementById('scatter-plot');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Clear assignments display
            updateAssignmentDisplay();
            
            // Generate a new triplet for the study tab
            generateNewTriplet();
            
            alert('All data has been cleared successfully.');
        }
        
        function exportData() {
            try {
                if (studyData.length === 0) {
                    alert('No data to export yet! Complete some similarity trials first.');
                    return;
                }
                
                const exportObject = {
                    version: "1.0",
                    exportDate: new Date().toISOString(),
                    totalTrials: studyData.length,
                    data: studyData
                };
                
                const dataStr = JSON.stringify(exportObject, null, 2);
                const now = new Date();
                const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD
                const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '_'); // HH_MM_SS
                const filename = `fm-synth-study-${dateStr}_${timeStr}.json`;
                
                // Try multiple methods in order of preference
                
                // Method 1: Standard download (might be blocked)
                if (!attemptStandardDownload(dataStr, filename)) {
                    // Method 2: Data URI download (works in more cases)
                    if (!attemptDataUriDownload(dataStr, filename)) {
                        // Method 3: Show copy dialog as last resort
                        showExportDialog(dataStr);
                    }
                }
                
            } catch (error) {
                console.error('Export error:', error);
                showExportDialog(JSON.stringify(studyData, null, 2));
            }
        }
        
        function attemptStandardDownload(dataStr, filename) {
            try {
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                
                // Try programmatic click
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                
                // Assume it worked if no error thrown
                console.log('Standard download attempted');
                return true;
            } catch (e) {
                console.error('Standard download failed:', e);
                return false;
            }
        }
        
        function attemptDataUriDownload(dataStr, filename) {
            try {
                // Use base64 encoding for better compatibility
                const base64 = btoa(unescape(encodeURIComponent(dataStr)));
                const dataUri = `data:application/json;base64,${base64}`;
                
                const link = document.createElement('a');
                link.href = dataUri;
                link.download = filename;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('Data URI download attempted');
                return true;
            } catch (e) {
                console.error('Data URI download failed:', e);
                return false;
            }
        }
        
        function showExportDialog(dataStr) {
            // Create a modal dialog with the data
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 8px;
                max-width: 80%;
                max-height: 80%;
                display: flex;
                flex-direction: column;
                gap: 15px;
            `;
            
            content.innerHTML = `
                <h2 style="margin: 0;">Export Data - Manual Save Required</h2>
                <p style="color: #666;">Due to browser restrictions, automatic download is blocked. Please copy the data below and save it manually:</p>
                <ol style="color: #666; margin: 5px 0;">
                    <li>Click "Copy to Clipboard" below</li>
                    <li>Open a text editor (Notepad, TextEdit, etc.)</li>
                    <li>Paste the content (Ctrl+V or Cmd+V)</li>
                    <li>Save the file with a .json extension</li>
                </ol>
                <textarea 
                    id="export-textarea"
                    style="width: 600px; height: 300px; font-family: monospace; font-size: 12px; padding: 10px; border: 1px solid #ddd; border-radius: 4px;"
                    readonly
                >${dataStr}</textarea>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="copyExportData()" 
                            style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px;">
                        ðŸ“‹ Copy to Clipboard
                    </button>
                    <button onclick="this.closest('div[style*=\"position: fixed\"]').remove()" 
                            style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px;">
                        Close
                    </button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Select all text
            const textarea = content.querySelector('textarea');
            textarea.select();
            textarea.focus();
        }
        
        function copyExportData() {
            const textarea = document.getElementById('export-textarea');
            textarea.select();
            
            try {
                // Try modern clipboard API first
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(textarea.value).then(() => {
                        alert('âœ… Data copied to clipboard! You can now paste it into a text editor and save as .json');
                    }).catch(() => {
                        // Fallback to older method
                        document.execCommand('copy');
                        alert('âœ… Data copied to clipboard! You can now paste it into a text editor and save as .json');
                    });
                } else {
                    // Use older execCommand method
                    document.execCommand('copy');
                    alert('âœ… Data copied to clipboard! You can now paste it into a text editor and save as .json');
                }
            } catch (err) {
                console.error('Failed to copy:', err);
                alert('Please manually select all text (Ctrl+A) and copy (Ctrl+C)');
            }
        }
        
        function copyToClipboard(text) {
            // Keep this for backward compatibility
            copyExportData();
        }
        
        function importData() {
            document.getElementById('file-input').click();
        }
        
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const raw = JSON.parse(event.target.result);
                    // Support the exported format (object with data array) and legacy plain array
                    let newTrials;
                    if (Array.isArray(raw)) {
                        newTrials = raw;
                    } else if (raw && Array.isArray(raw.data)) {
                        newTrials = raw.data;
                    } else {
                        throw new Error('Unrecognized JSON format: expected an array or an object with a data[] property');
                    }

                    // Optional: de-duplicate by timestamp + choice + A/B/X params signature
                    const existingKeys = new Set(
                        studyData.map(t => {
                            const keyParts = ['A','B','X'].map(k => t[k] ? `${t[k].carrier}|${t[k].harmRatio}|${t[k].modIndex}` : '');
                            return `${t.timestamp||''}|${t.choice||''}|${keyParts.join('||')}`;
                        })
                    );
                    const filteredNew = newTrials.filter(t => {
                        if (!t || !t.A || !t.B || !t.X) return false; // basic validation
                        const keyParts = ['A','B','X'].map(k => t[k] ? `${t[k].carrier}|${t[k].harmRatio}|${t[k].modIndex}` : '');
                        const key = `${t.timestamp||''}|${t.choice||''}|${keyParts.join('||')}`;
                        if (existingKeys.has(key)) return false;
                        existingKeys.add(key);
                        return true;
                    });

                    const beforeCount = studyData.length;
                    studyData = studyData.concat(filteredNew);
                    localStorage.setItem('fmSynthStudyData', JSON.stringify(studyData));

                    // Update counts in UI if elements exist
                    const dataCountEl = document.getElementById('data-count');
                    if (dataCountEl) dataCountEl.textContent = studyData.length;
                    updateUniqueSoundsCount();

                    const importedCount = filteredNew.length;
                    alert(`Imported ${importedCount} new trials successfully (ignored ${newTrials.length - importedCount} duplicates). Total now: ${studyData.length}`);
                } catch (err) {
                    alert('Error importing data: ' + err.message);
                }
            };
            reader.readAsText(file);
        });
        
        function showDataInConsole() {
            if (studyData.length === 0) {
                alert('No data collected yet!');
                return;
            }
            
            console.log('=== FM Synth Study Data ===');
            console.log(`Total trials: ${studyData.length}`);
            console.log('Data:', studyData);
            console.log('JSON (copy this):', JSON.stringify(studyData, null, 2));
            
            alert(`Data has been printed to the browser console.\n\nTo view it:\n1. Press F12 or right-click â†’ Inspect\n2. Go to the Console tab\n3. Copy the JSON data from there`);
        }
        
        // Alternative export method using data URI
        function exportDataAlternative() {
            if (studyData.length === 0) {
                alert('No data to export yet!');
                return;
            }
            
            const exportObject = {
                version: "1.0",
                exportDate: new Date().toISOString(),
                totalTrials: studyData.length,
                data: studyData
            };
            
            const dataStr = JSON.stringify(exportObject, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 10); // YYYY-MM-DD
            const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '_'); // HH_MM_SS
            const filename = `fm-synth-study-${dateStr}_${timeStr}.json`;
            
            const link = document.createElement('a');
            link.setAttribute('href', dataUri);
            link.setAttribute('download', filename);
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Assignment functions for visualization
        function showLastTouchedIndicator(point) {
            // Remove existing indicator if any
            const existingIndicator = document.querySelector('.last-touched-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            // Create new indicator
            const indicator = document.createElement('div');
            indicator.className = 'last-touched-indicator';
            
            const canvas = document.getElementById('scatter-plot');
            const rect = canvas.getBoundingClientRect();
            
            indicator.style.left = (rect.left + point.x - point.radius - 3) + 'px';
            indicator.style.top = (rect.top + point.y - point.radius - 3) + 'px';
            indicator.style.width = (point.radius * 2 + 6) + 'px';
            indicator.style.height = (point.radius * 2 + 6) + 'px';
            
            document.body.appendChild(indicator);
            
            // Remove after animation
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.remove();
                }
            }, 1500);
        }
        
        function assignPoint(role) {
            if (!lastTouchedPoint) {
                alert('Please click on a point in the visualization first!');
                return;
            }
            
            // Assign the point
            assignedPoints[role] = {
                params: lastTouchedPoint.params,
                color: lastTouchedPoint.color
            };
            
            // Update UI
            updateAssignmentDisplay();
            
            // Clear last touched point
            lastTouchedPoint = null;
        }
        
        function updateAssignmentDisplay() {
            // Update each assignment card
            ['A', 'B', 'X'].forEach(role => {
                const card = document.getElementById(`assignment-card-${role.toLowerCase()}`);
                const content = document.getElementById(`assignment-content-${role.toLowerCase()}`);
                
                if (assignedPoints[role]) {
                    // Card is assigned - show the assigned content
                    card.classList.add('assigned');
                    
                    content.innerHTML = `
                        <button class="remove-btn" onclick="removeAssignment('${role}')">Ã—</button>
                        <h3>Sound ${role}</h3>
                        <button class="play-btn" onclick="playAssignedSound('${role}')">Play Sound ${role}</button>
                        <div class="params-display">
                            Carrier: ${assignedPoints[role].params.carrier.toFixed(1)} Hz<br>
                            Harm Ratio: ${assignedPoints[role].params.harmRatio.toFixed(2)}<br>
                            Mod Index: ${assignedPoints[role].params.modIndex.toFixed(2)}
                        </div>
                    `;
                } else {
                    // Card is unassigned - show the assignment button
                    card.classList.remove('assigned');
                    
                    content.innerHTML = `
                        <button class="assignment-btn" onclick="assignPoint('${role}')" id="assign-${role.toLowerCase()}-btn">Use as ${role}</button>
                    `;
                }
            });
            
            // Show/hide controls based on assignments
            const allAssigned = assignedPoints.A && assignedPoints.B && assignedPoints.X;
            document.getElementById('choice-controls').style.display = allAssigned ? 'block' : 'none';
            
            // Redraw visualization to update labels
            drawVisualization();
        }
        
        function removeAssignment(role) {
            assignedPoints[role] = null;
            updateAssignmentDisplay();
        }
        
        function playAssignedSound(role) {
            if (assignedPoints[role]) {
                const params = assignedPoints[role].params;
                playFMSound(params.carrier, params.harmRatio, params.modIndex);
            }
        }
        
        function clearAssignments() {
            assignedPoints = { A: null, B: null, X: null };
            updateAssignmentDisplay();
        }
        
        function recordVisualizationChoice(choice) {
            if (!assignedPoints.A || !assignedPoints.B || !assignedPoints.X) {
                alert('Please assign all three points first!');
                return;
            }
            
            // Create trial data from assigned points
            const trialData = {
                A: assignedPoints.A.params,
                B: assignedPoints.B.params,
                X: assignedPoints.X.params,
                choice: choice,
                timestamp: new Date().toISOString(),
                responseTime: new Date().toISOString(),
                source: 'visualization' // Mark that this came from visualization
            };
            
            // Add to study data
            studyData.push(trialData);
            localStorage.setItem('fmSynthStudyData', JSON.stringify(studyData));
            
            // Update global stats
            updateGlobalStats();
            
            // Clear assignments
            clearAssignments();
            
            // Update visualization with new data
            updateVisualization();
            
            // Flash feedback on the choice controls
            const choiceControls = document.getElementById('choice-controls');
            if (choiceControls) {
                choiceControls.style.backgroundColor = '#4CAF50';
                choiceControls.style.borderRadius = '4px';
                choiceControls.style.padding = '10px';
                setTimeout(() => {
                    choiceControls.style.backgroundColor = 'transparent';
                    choiceControls.style.padding = '0';
                }, 300);
            }
        }
        
        // Load saved data on startup
        window.addEventListener('load', function() {
            const savedData = localStorage.getItem('fmSynthStudyData');
            if (savedData) {
                studyData = JSON.parse(savedData);
                updateGlobalStats();
            }
            
            // Generate initial triplet
            generateNewTriplet();
            
            // Set up canvas resizing
            resizeCanvas();
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            resizeCanvas();
        });
        
        // Also resize when switching tabs
        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // Update visualization if switching to that tab
            if (tabName === 'visualization') {
                setTimeout(() => {
                    resizeCanvas();
                    // updateVisualization();
                }, 10);
            }
        }
    </script>
</body>
</html>